#!/usr/bin/env python3
import sys
import os

print("开始运行XML生成脚本...")
print(f"Python版本: {sys.version}")
print(f"当前工作目录: {os.getcwd()}")

try:
    import openpyxl
    print("✓ openpyxl包已安装")
except ImportError as e:
    print("✗ openpyxl包未安装")
    print(f"错误: {e}")
    print("\n请先安装openpyxl包:")
    print("python -m pip install openpyxl")
    sys.exit(1)

import re
import shutil

header = '''<!-- ==============================================================================  -->
<!--                                                                                 -->
<!--             CADENCE                    Copyright (c) 2015                       -->
<!--                                        Cadence Design Systems, Inc.             -->
<!--                                        All rights reserved.                     -->
<!--                                                                                 -->
<!--   This work may not be copied, modified, re-published, uploaded, executed, or   -->
<!--   distributed in any way, in any medium, whether in whole or in part, without   -->
<!--   prior written permission from Cadence Design Systems, Inc.                    -->
<!-- ==============================================================================  -->
<!--                                                                                 -->
<!--    Author                : autogenerated                                        -->
<!--                                                                                 -->
<!--    Date                  : $Date$                                               -->
<!--                                                                                 -->
<!--    Last Changed Revision : $LastChangedRevision$                                -->
<!--                                                                                 -->
<!-- ==============================================================================  -->
<!--    Description                                                                  -->
<!--                                                                                 -->
<!--    This file was generated automatically by dedicated script                    -->
<!-- ==============================================================================  -->
<spirit:component xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009
                      http://www.accellera.org/XMLSchema/SPIRIT/1685-2009/index.xsd">
  <spirit:vendor>Cadence</spirit:vendor>
  <spirit:library>cdns_lib</spirit:library>
  <spirit:name>autogen</spirit:name>
  <spirit:version>1.00</spirit:version>
  <spirit:memoryMaps>
    <spirit:memoryMap>
      <spirit:name>xa0</spirit:name>
      <spirit:addressBlock>
        <spirit:name>dataslice_Rfile</spirit:name>
        <spirit:displayName>Data Slice registers.</spirit:displayName>
        <spirit:baseAddress>0x3000</spirit:baseAddress>
        <spirit:range>0x2c</spirit:range>
        <spirit:width>32</spirit:width>
'''

ender ='''
      </spirit:addressBlock>'''

#define addr width, DWORD 4Bytes
address_len = 14
#define Register table title names
KEY_OFFSET = "OFFSET"
KEY_FIELD = "FIELD"
KEY_SIGNAL = "SIGNAL"
KEY_SIGNAL_FIELD = "SIGNAL_FIELD"
KEY_OP = "OP"
KEY_RESET_VALUE = "RESET_VALUE"
KEY_DES = "Description"
KEY_REGNAME = "REGNAME"
KEY_REGDESC = "REGDesc"
RESERVED = "Reserved"
MODIFIED_WRITE_VALUE = "modifiedWriteValue"
#misc
address_h = 0
address_l = 0
#define signal names
REG_CLK = "clk"
REG_RSTN = "rst_n"
REG_WR = "reg_write"
REG_ADDR = "reg_addr"
REG_WDATA = "reg_wdata"
REG_RDATA = "reg_rdata"


def read_workbook(data_book, sheet_name):
    print("Reading: ", sheet_name)
    register_dict = {}
    keys = []
    register_title = {}
    register_desc = {}
    current_regname = ""  # 用于跟踪当前寄存器名

    wb = openpyxl.load_workbook(data_book, "r")
    sheet = wb[sheet_name]

    row_num = 0
    for row in sheet.values:
        # find the keys in first row
        row_num = row_num + 1
        #print("Read line"+str(row_num))
        if len(keys) == 0:
            for i in range(sheet.max_column):
                keys.append(row[i])
            continue

        register_data = {}
        for i in range(sheet.max_column):
            if row[i] is None:
                register_data[keys[i]] = None
            else:
                register_data[keys[i]] = str(row[i]).strip()
        
        # 跳过空行或无效行
        if (register_data[KEY_FIELD] is None or 
            register_data[KEY_SIGNAL] is None or 
            register_data[KEY_OP] is None or 
            register_data[KEY_RESET_VALUE] is None):
            continue

        # 更新当前寄存器名
        if register_data[KEY_REGNAME] is not None and register_data[KEY_REGNAME].strip() != "":
            current_regname = register_data[KEY_REGNAME]
        
        # 如果当前行的REGNAME为空，使用上一个寄存器名
        if register_data[KEY_REGNAME] is None or register_data[KEY_REGNAME].strip() == "":
            register_data[KEY_REGNAME] = current_regname

        # add signal_field
        # ws: add [] for msb:lsb
        register_data[KEY_FIELD] = "[{}]".format(register_data[KEY_FIELD])
        #print(register_data[KEY_SIGNAL])
        field_length = calc_field_size(register_data[KEY_FIELD])
        if field_length == 1:
            register_data[KEY_SIGNAL_FIELD] = ""
        else:
            register_data[KEY_SIGNAL_FIELD] = "[{}:0]".format(field_length - 1)

        # fix none columns
        offset = register_data[KEY_OFFSET]
        if offset is None:
            offset = prev_offset
            #print(offset)
        assert isinstance(offset, object)
        prev_offset = offset

        if offset not in register_dict.keys():
            register_dict[offset] = []
        register_dict[offset].append(register_data)
        
        if offset not in register_title.keys():
            if KEY_REGNAME in keys:
                if register_data[KEY_REGNAME] is not None:
                    register_title[offset] = register_data[KEY_REGNAME]
            else:
                register_title[offset] = ""
            
        if offset not in register_desc.keys():
            if KEY_DES in keys:
                if register_data[KEY_DES] is not None:
                    register_desc[offset] = register_data[KEY_DES]  # 使用Description作为描述
            else:
                register_desc[offset] = ""
                    
        #print(register_data)

    return register_dict, register_title, register_desc


def get_address_size(field_str):
    regex = re.compile(r'input\s*\[\s*(\d+)\s*:\s*(\d+)\s*\]\s+\w+addr[,\s]+')
    mo = regex.search(field_str)
    if mo is not None:
        return int(mo.group(1)), int(mo.group(2))
    else:
        return 0, 0

# get 32bit default value
def get_default(register_data):
    rt = 0
    for field in register_data:
        rst = field[KEY_RESET_VALUE]
        h = re.search(r"'h(\w+)",rst) 
        d = re.search(r"'d(\w+)",rst) 
        b = re.search(r"'b(\w+)",rst) 
        if h is not None:
            r = h.group(1)
            r = int(r, 16) 
        if d is not None:
            r = d.group(1)
            r = int(r, 10)
        if b is not None:
            r = b.group(1)
            r = int(r, 2)
        off = calc_field_offset(field[KEY_FIELD])
        rt = rt + (r << off)
    return hex(rt)
            
    
def calc_field_size(field_str):
    #print(field_str)
    regex_more_bits = re.compile(r'\[(\d+):(\d+)\]')
    regex_one_bit = re.compile(r'\[(\d+)\]')

    mo = regex_more_bits.search(field_str)
    if mo is None:
        mo = regex_one_bit.search(field_str)
        if mo is None:
            raise Exception("Unkonw: " + field_str)
        return 1
    else:
        length = int(mo.group(1)) - int(mo.group(2)) + 1
    return length
    
def calc_field_offset(field_str):
    #print(field_str)
    regex_more_bits = re.compile(r'\[(\d+):(\d+)\]')
    regex_one_bit = re.compile(r'\[(\d+)\]')

    mo = regex_more_bits.search(field_str)
    if mo is None:
        mo = regex_one_bit.search(field_str)
        if mo is None:
            raise Exception("Unkonw: " + field_str)
        return int(mo.group(1))
    else:
        return int(mo.group(2))



# print xml
def gen_xml(register_block, xml_file, mode):
    global address_h
    global address_l
    global address_len
    
    register_dict, register_title, register_desc = register_block
    f_new = open(xml_file, mode, encoding='utf-8')

    try:
        f_new.write(header)
      
        for offset in register_dict.keys():
            register_data = register_dict[offset]
            df = get_default(register_data)
            name = ""
            desc = ""
            # 处理十六进制和十进制offset
            if isinstance(offset, str) and offset.startswith('0x'):
                offset_real = offset
            else:
                offset_real = hex(int(offset)*4)
            if offset in register_title.keys():
                name = register_title[offset]
            if offset in register_desc.keys():
                desc = register_desc[offset]
            line  = "        <spirit:register>\n"
            line += "          <spirit:name>{}</spirit:name>\n".format(name)
            line += "          <spirit:description>{}</spirit:description>\n".format(desc)
            line += "          <spirit:addressOffset>{}</spirit:addressOffset>\n".format(str(offset_real))
            line += "          <spirit:size>{}</spirit:size>\n".format(32)
            line += "          <spirit:reset>\n"
            line += "            <spirit:value>{}</spirit:value>\n".format(df)
            line += "          </spirit:reset>\n"  
            f_new.write(line)

            for field in register_data:
                #print(field)
                if field[KEY_SIGNAL] == "Reserved":
                    continue
                bo = calc_field_offset(field[KEY_FIELD])
                bw = calc_field_size(field[KEY_FIELD])
                d = "null"
                if re.match("[Rr][Oo]", field[KEY_OP]):
                    d = "read-only"
                    hw = "write-only"
                elif re.match("[Rr][Ww]", field[KEY_OP]):
                    d = "read-write"
                    hw = "read-only"
                
                # 生成字段名：REGNAME + FIELD组合
                regname = field.get(KEY_REGNAME, "")
                field_range = field[KEY_FIELD].strip("[]")  # 去掉方括号
                if regname and regname != "None" and regname.strip() != "":
                    # 将字段范围中的冒号替换为下划线，生成类似 phy_pma_lane_map_reg_15_14 的格式
                    field_range_formatted = field_range.replace(":", "_")
                    field_name = f"{regname}_{field_range_formatted}"
                else:
                    # 如果没有REGNAME，则使用SIGNAL作为备选
                    field_name = field[KEY_SIGNAL]
                              
                line  = "          <spirit:field>\n"
                line += "            <spirit:name>{}</spirit:name>\n".format(field_name)
                line += "            <spirit:description>"
                line += "{}".format(field[KEY_DES])
                line += "\n            </spirit:description>\n"
                line += "            <spirit:bitOffset>{}</spirit:bitOffset>\n".format(bo)
                line += "            <spirit:bitWidth>{}</spirit:bitWidth>\n".format(bw)
                line += "            <spirit:access>{}</spirit:access>\n".format(d)
                line += "            <spirit:vendorExtensions>\n"
                line += "              <spirit:hw_access>{}</spirit:hw_access>\n".format(hw)
                line += "              <spirit:we_type>no-write-enable</spirit:we_type>\n"
                line += "            </spirit:vendorExtensions>\n"
                line += "          </spirit:field>\n\n"
                f_new.write(line)
                
            line = "        </spirit:register>\n\n"
            f_new.write(line)
        
        f_new.write(ender)    
    except Exception as err:
        print(offset)
        print(err)
        raise err

    f_new.close()
    

# 指定Excel文件路径
excel_file_path = r"C:\Users\swenchen\Downloads\USB4 Register_Reference_Manual.xlsx"

# 定义模块配置
modules = [
    {
        "sheet_name": "PHY Top REG",
        "xml_file": "sd3101_t4gp_phy_pcs_cmn_registers.xml",
        "block_name": "phy_pcs_cmn_Rfile",
        "display_name": "PHY PCS CMN registers.",
        "base_address": "0x30000"
    },
    {
        "sheet_name": "PMA CMN REG",
        "xml_file": "sd3101_t4gp_pma_cmn_registers.xml",
        "block_name": "pma_cmn_Rfile",
        "display_name": "PMA CMN registers.",
        "base_address": "0x00000"
    },
    {
        "sheet_name": "PMA TX REG",
        "xml_file": "sd3101_t4gp_pma_tx_lane_registers.xml",
        "block_name": "pma_tx_lane_Rfile",
        "display_name": "PMA TX Lane registers.",
        "base_address": "0x10000"
    },
    {
        "sheet_name": "PMA RX REG",
        "xml_file": "sd3101_t4gp_pma_rx_lane_registers.xml",
        "block_name": "pma_rx_lane_Rfile",
        "display_name": "PMA RX Lane registers.",
        "base_address": "0x20000"
    }
]

# 为每个模块生成独立的XML文件
for module in modules:
    print(f"\n处理模块: {module['sheet_name']}")
    
    # 从XML文件名中提取spirit:name
    # 例如: sd3101_t4gp_phy_pcs_cmn_registers.xml -> phy_pcs_cmn_registers
    xml_filename = module['xml_file']
    if xml_filename.startswith('sd3101_t4gp_'):
        spirit_name = xml_filename[12:]  # 去掉 "sd3101_t4gp_" 前缀
        spirit_name = spirit_name.replace('.xml', '')  # 去掉 .xml 后缀
    else:
        spirit_name = xml_filename.replace('.xml', '')  # 如果不是预期格式，直接去掉.xml
    
    # 设置特定模块的header
    header = f'''<!-- ==============================================================================  -->
<!--                                                                                 -->
<!--             CADENCE                    Copyright (c) 2015                       -->
<!--                                        Cadence Design Systems, Inc.             -->
<!--                                        All rights reserved.                     -->
<!--                                                                                 -->
<!--   This work may not be copied, modified, re-published, uploaded, executed, or   -->
<!--   distributed in any way, in any medium, whether in whole or in part, without   -->
<!--   prior written permission from Cadence Design Systems, Inc.                    -->
<!-- ==============================================================================  -->
<!--                                                                                 -->
<!--    Author                : autogenerated                                        -->
<!--                                                                                 -->
<!--    Date                  : $Date$                                               -->
<!--                                                                                 -->
<!--    Last Changed Revision : $LastChangedRevision$                                -->
<!--                                                                                 -->
<!-- ==============================================================================  -->
<!--    Description                                                                  -->
<!--                                                                                 -->
<!--    This file was generated automatically by dedicated script                    -->
<!-- ==============================================================================  -->
<spirit:component xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009
                      http://www.accellera.org/XMLSchema/SPIRIT/1685-2009/index.xsd">
  <spirit:vendor>Cadence</spirit:vendor>
  <spirit:library>cdns_lib</spirit:library>
  <spirit:name>{spirit_name}</spirit:name>
  <spirit:version>1685-2009</spirit:version>
  <spirit:memoryMaps>
    <spirit:memoryMap>
      <spirit:name>sd3101_t4_registers</spirit:name>
      <spirit:addressBlock>
        <spirit:name>sd3101_phy_registers</spirit:name>
        <spirit:displayName>{module['display_name']}</spirit:displayName>
        <spirit:baseAddress>{module['base_address']}</spirit:baseAddress>
        <spirit:range>0x2c</spirit:range>
        <spirit:width>32</spirit:width>
'''
    
    # 设置结束标签
    ender = '''
      </spirit:addressBlock>

    </spirit:memoryMap>
  </spirit:memoryMaps>
</spirit:component>
'''
    
    try:
        # 读取工作表并生成XML
        registers = read_workbook(excel_file_path, module['sheet_name'])
        gen_xml(registers, module['xml_file'], "w")
        print(f"✓ 成功生成: {module['xml_file']}")
    except Exception as e:
        print(f"✗ 处理 {module['sheet_name']} 时出错: {e}")
        continue
