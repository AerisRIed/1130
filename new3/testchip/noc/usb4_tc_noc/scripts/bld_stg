#!/usr/bin/perl
# +---------------------------------------------------------------------------+
# |  Copyright (c) 2013-2025 Cadence Design Systems Inc. ALL RIGHTS RESERVED. |
# |                                                                           |
# |   These coded instructions, statements, and computer programs             |
# |   are the copyrighted works and confidential proprietary                  |
# |   information of Tensilica Inc.  They may not be modified,                |
# |   copied, reproduced, distributed, or disclosed to third                  |
# |   parties in any manner, medium, or form, in whole or in part,            |
# |   without the prior written consent of Tensilica Inc.                     m
# +---------------------------------------------------------------------------+

use lib ('./lib');
use Params;
use Cwd; 
use List::Util qw(min max);

my $DENALI = "\$CDN_VIP_ROOT/tools.lnx86/denali_64bit";
my $IPG_WKAREA = $ENV{IPG_WKAREA};

my $stg = defined $ENV{CDN_SYSVIP_ROOT} ? $ENV{CDN_SYSVIP_ROOT}."/tools/stg/bin/stg" : "/cad/cadence_root/SYSVIP01/tools/stg/bin/stg";
if (-d "${testbench}") {
    system("rm -rf ${testbench}");
}
system("$stg -gen -top noc.csv -target_dir $testbench -dut_name $topMod -prefix dut -enable_ipc");

my %fusaConfig;
my %fusaCheckerConfig;
my @isolation_links;
parse_ports();
parse_fusa_checkers();
if ((scalar(keys %fusaCheckerConfig) > 0) && (scalar(keys %fusaConfig) > 0)) {
    fusa_updates();
}
my $axi4p = 0;
if($topMod =~ /Axi4P/) {$axi4p = 1;}
if($axi4p && ($rreorder && $wreorder)) {
  system("cp $IPG_WKAREA/verification/stg/rob_scoreboard.sv ${testbench}/env/sv/");
  my $sb = "${testbench}/env/sv/rob_scoreboard.sv";
  system("sed -i 's/RID_WIDTH/$ridW-1/g' $sb");
  system("sed -i 's/WID_WIDTH/$widW-1/g' $sb");
  system("sed -i 's/maxRO/$maxRO/g' $sb");
  system("sed -i 's/maxWO/$maxWO/g' $sb");
  my $envPkg = "${testbench}/env/sv/dut_${topMod}_env_pkg.sv";
  system("sed -i 's/\`include \"dut_${topMod}_env_cfg.sv\"/\`include \"rob_scoreboard.sv\"\\n\   `include \"dut_${topMod}_env_cfg.sv\"/g' $envPkg");
  my $env = "${testbench}/env/sv/dut_${topMod}_env_base.sv";
  open(INFILE,  "<$env");
  open(OUTFILE, ">tmpe");
   my $set = 0;
  foreach my $line (<INFILE>) {
      my $pre_addition  = '';
      my $post_addition = '';

      if ($line =~ /dut_${topMod}_env_scoreboard_container all_scoreboards/) {
           $post_addition = <<"END_ADD";
   rob_scoreboard rob_sb;
   cdn_stg_routing_model_port mst_port[\$];
   cdn_stg_routing_model_port slv_port[\$];
   cdnStgAxiUvmSlaveAgent p_cdnStgAxiUvmSlaveAgent;
   cdnStgAxiUvmMasterAgent p_cdnStgAxiUvmMasterAgent;
END_ADD
      print OUTFILE "$line";
      print OUTFILE "$post_addition";
      }
      elsif ($line =~ /vseqr = dut_${topMod}_env_vsequencer::type_id::create/) {
           $post_addition = <<"END_ADD";
      rob_sb = rob_scoreboard::type_id::create("rob_sb",this);
END_ADD
      print OUTFILE "$line";
      print OUTFILE "$post_addition";
      }
      elsif ($line =~ /all_scoreboards.scoreboard.routing_model = routing_model;/) {
           $pre_addition = <<"END_ADD";
      axi_connect_code(); 
      routing_model.get_masters(mst_port);
      routing_model.get_slaves(slv_port);

      \$cast(p_cdnStgAxiUvmSlaveAgent,mst_port[0].p_agents[0]);
      \$cast(p_cdnStgAxiUvmMasterAgent,slv_port[0].p_agents[0]);

      void'(p_cdnStgAxiUvmSlaveAgent.inst.setCallback(DENALI_CDN_AXI_CB_EndedAddress));
      void'(p_cdnStgAxiUvmSlaveAgent.inst.setCallback(DENALI_CDN_AXI_CB_Ended));
      void'(p_cdnStgAxiUvmMasterAgent.inst.setCallback(DENALI_CDN_AXI_CB_StartedResponse));
      void'(p_cdnStgAxiUvmMasterAgent.inst.setCallback(DENALI_CDN_AXI_CB_Ended));

      void'(p_cdnStgAxiUvmSlaveAgent.monitor.EndedAddressCbPort.connect(rob_sb.rd_rob_received_request_imp));
      void'(p_cdnStgAxiUvmSlaveAgent.monitor.EndedCbPort.connect(rob_sb.rob_sent_resp_imp));
      void'(p_cdnStgAxiUvmMasterAgent.monitor.StartedResponseCbPort.connect(rob_sb.rd_rob_sent_request_imp));
      void'(p_cdnStgAxiUvmMasterAgent.monitor.EndedCbPort.connect(rob_sb.rob_received_resp_imp));
END_ADD
      print OUTFILE "$line";
      print OUTFILE "$pre_addition";
      }
     # elsif($line =~ /axi_connect_code()/ && !$set) {
     #     $set = 1;
     # }
      else {print OUTFILE "$line";}

  }
        close(INFILE);
        close(OUTFILE);
        system("mv tmpe $env");

   
}

print STDERR "Generating usr code\n";
system("cp -rf usr/* ${testbench}/usr");

#include new files in usr package
my $usrPkg = "${testbench}/usr/dut_${topMod}_usr_pkg.sv";
system("sed -i 's/endpackage/\`include \"usr_includes.sv\"\\nendpackage/g' $usrPkg");

#HACK: This is added to handle sn STG problem introduced in the latest release.
my $vseq_lib = "${testbench}/env/sv/dut_${topMod}_env_vseq_lib.sv";
system("sed -i 's/routing_model.choose_active_master()/routing_model.get_port_by_id(master_ids[0])/g' $vseq_lib");

my $dbgBaseAddr;
my $dbgEndAddr;
if ($inclDbgReg) {
    $dbgBaseAddr = sprintf("64\'h%x", $dbgBase);
    $dbgEndAddr = sprintf("64\'h%x", $dbgBase+4095);
}

#STG generates 64-bit HAUSER connections but it's allowed to have HAUSER to be upto 128 bits wide
#The unconnected user bits can be a problem if the flits go through error correction curcuit and these Zs get propagated to the entire flitwidth, corrupting fields which don't correspond to user bits (e.g. dest id can get corrupted and lead to arbitration failures)
#Adding this hack to workaround STG issue.

if ($ahbIeaCnt > 0) {
    system("sed -i 's/wire \\[63:0\\] HAUSER__/wire [127:0] HAUSER__/g' testbench/dut_${topMod}.sv");
}

# Update Top to Tie Netlist Pins
update_for_gls();

my $add_axiiea_constraints = ($axi4IeaCnt > 0);
my $add_ahbiea_constraints = ($ahbIeaCnt > 0);
my $add_apbiea_constraints = ($apbIeaCnt > 0);
#make changes to usr_tb file. These include:
#Additional constraints
#Enabling callbacks
update_usr_tb();
update_usr_tb_err_per_pkt();

#Setup SPA Regression
spa_commands();
setup_spa_regression();

# Set Cache Size as per widest TEA
set_cache_size();

sub set_cache_size {
  #Calculate Widest TEA
  my $cacheSize = 0;
  foreach my $tea (keys %teaInfo) {
    my $teaSize  = $teaInfo{$tea}->{dataW} / 8;
    if($teaSize > $cacheSize){
      $cacheSize = $teaSize;
    }
  }
  # Min Requirement is 16 bytes as per spec
  if($cacheSize < 16) {
    $cacheSize = 16;
  }
  
  # Set Cache Size for all ACE-Lite IEA
  foreach my $name (@axi4IeaNames) {
    foreach my $iea (keys %ieaInfo) {
      if($iea eq ${name}){
        my $ieaBus   = $ieaInfo{$iea}->{bus};
        if($ieaBus eq "ACELite"){
          my $usrCfgAxiIea = "${testbench}/usr/usr_uvm_cfg/active_master_${topMod}_${name}_config_usr.sv";
          my $usrCfg = "\\t\tset_cache_line_size(${cacheSize});\\n";
          system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgAxiIea");
  
          $usrCfgAxiIea = "${testbench}/usr/usr_uvm_cfg/passive_slave_${topMod}_${name}_config_usr.sv";
          $usrCfg = "\\t\tset_cache_line_size(${cacheSize});\\n";
          system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgAxiIea");
        }
        last;
      }
    }
  }
  # Set Cache Size for all ACE-Lite TEA
  foreach my $name (@axi4TeaNames) {
    foreach my $tea (keys %teaInfo) {
      if($tea eq ${name}){
        my $teaBus   = $teaInfo{$tea}->{bus};
        if($teaBus eq "ACELite"){
          my $usrCfgAxiTea = "${testbench}/usr/usr_uvm_cfg/active_slave_${topMod}_${name}_config_usr.sv";
          my $usrCfg = "\\t\tset_cache_line_size(${cacheSize});\\n";
          system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgAxiTea");
  
          $usrCfgAxiTea = "${testbench}/usr/usr_uvm_cfg/passive_master_${topMod}_${name}_config_usr.sv";
          $usrCfg = "\\t\tset_cache_line_size(${cacheSize});\\n";
          system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgAxiTea");
        }
        last;
      }
    }
  }
  #Update Cache Size for SVD
  my $dutusrenv = "${testbench}/usr/dut_${topMod}_usr_env.sv";
  open(INFILE,  "<$dutusrenv");
  open(OUTFILE, ">tmp");
  
  foreach my $line (<INFILE>) {
    if (($line =~ /inst\.regWrite\(DENALI_SVD_REG_CacheLineSize/)) {
      print OUTFILE "\tinst.regWrite(DENALI_SVD_REG_CacheLineSize, ${cacheSize});\n";
    } else {
      print OUTFILE "$line";
    }
  }
  close(INFILE);
  close(OUTFILE);
  system("mv tmp $dutusrenv");
}
foreach my $name (@axi4TeaNames) {
    my $usrCfgAxiTea = "${testbench}/usr/usr_uvm_cfg/active_slave_${topMod}_${name}_config_usr.sv";
    my $usrCfg = "\\tif (\$test\$plusargs(\"randomize_idle\"))\\n\\t\\tset_random_data_when_not_valid(1);\\n";
    $usrCfg .= "\\tif (\$test\$plusargs(\"random_response_order\")) begin\\n";
    $usrCfg .= "\\tset_read_ordering_algorithm(CDN_AXI_CFG_READ_ORDERING_ALGORITHM_RANDOM_NO_INTERLEAVING);\\n";
    $usrCfg .= "\\tset_write_resp_ordering_algorithm(CDN_AXI_CFG_WRITE_RESP_ORDERING_ALGORITHM_FULL_RANDOM);\\n";
    $usrCfg .= "\\tend\\n";
    
    system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgAxiTea"); 
}
foreach my $name (@apbIeaNames) {
    my $usrCfgApbIea = "${testbench}/usr/usr_uvm_cfg/active_master_${topMod}_${name}_config_usr.sv";
    my $usrCfg       = "\\t\\tif (\$test\$plusargs(\"randomize_idle\"))\\n\\t\\t\\t\\tset_randomize_idle(1);\\n\\n";
    my $usrCfg .= "\\t\\set_enable_tracker(0);\\n\\n";
    if ($apbIeaInfo{$name}->{userReqW} > 0) {
        $usrCfg .= "\\t\\set_auser_width(" . $apbIeaInfo{$name}->{userReqW} . ");\\n\\n";
    }
    if ($apbIeaInfo{$name}->{userDataW} > 0) {
        $usrCfg .= "\\t\\set_duser_width(" . $apbIeaInfo{$name}->{userDataW} . ");\\n\\n";
    }
    if ($apbIeaInfo{$name}->{userRespW} > 0) {
        $usrCfg .= "\\t\\set_buser_width(" . $apbIeaInfo{$name}->{userRespW} . ");\\n\\n";
    }
    system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgApbIea");

    my $usrCfgApbIea = "${testbench}/usr/usr_uvm_cfg/passive_slave_${topMod}_${name}_config_usr.sv";
    system(
        "sed -i 's/endfunction: setFieldsValues/\\t\\tset_enable_tracker(0);\\n\\\tendfunction: setFieldsValues/g' $usrCfgApbIea"
    );
}

foreach my $name (@apbTeaNames) {
    my $usrCfgApbTea = "${testbench}/usr/usr_uvm_cfg/active_slave_${topMod}_${name}_config_usr.sv";
    my $usrCfg       = "\\t\\tif (\$test\$plusargs(\"randomize_idle\"))\\n\\t\\t\\t\\tset_randomize_idle(1);\\n\\n";
    $usrCfg .= "\\t\\set_enable_tracker(0);\\n\\n";
    if ($apbTeaInfo{$name}->{userReqW} > 0) {
        $usrCfg .= "\\t\\set_auser_width(" . $apbTeaInfo{$name}->{userReqW} . ");\\n\\n";
    }
    if ($apbTeaInfo{$name}->{userDataW} > 0) {
        $usrCfg .= "\\t\\set_duser_width(" . $apbTeaInfo{$name}->{userDataW} . ");\\n\\n";
    }
    if ($apbTeaInfo{$name}->{userRespW} > 0) {
        $usrCfg .= "\\t\\set_buser_width(" . $apbTeaInfo{$name}->{userRespW} . ");\\n\\n";
    }
    system("sed -i 's/endfunction: setFieldsValues/$usrCfg\\tendfunction: setFieldsValues/g' $usrCfgApbTea");

    my $usrCfgApbTea = "${testbench}/usr/usr_uvm_cfg/passive_master_${topMod}_${name}_config_usr.sv";
    system(
        "sed -i 's/endfunction: setFieldsValues/\\t\\tset_enable_tracker(0);\\n\\\tendfunction: setFieldsValues/g' $usrCfgApbTea"
    );
}
foreach my $name (@apbTeaNames) {
    my $dut = "${testbench}/dut_${topMod}.sv";
    system("sed -i 's/.${name}_prdata(PRDATA__${name}_prdata),/.${name}_prdata(PREADY__${name}_pready ? PRDATA__${name}_prdata : \$urandom),/g' $dut"); 
}

#Support for Enabling EBT and Continue on Error Randomly on AHB IEA
foreach my $name (@ahbIeaNames) {
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/active_master_${topMod}_${name}_config_usr.sv";
    open(INFILE,  "<$usrCfgAhbIea");
    open(OUTFILE, ">tmp");
    my $ebtDist = rand(10);
    my $ebtStr  = <<"EBT";

        if (\$test\$plusargs("apb_err_check") || (\$urandom_range(0, 10)<3)) begin
   		    set_continue_on_error(1);
        end

EBT
    foreach my $line (<INFILE>) {
        my $pre_addition = '';
        if ($line =~ /endfunction: setFieldsValues/) {
            $pre_addition .= $ebtStr;
        }
        print OUTFILE "$pre_addition";
        print OUTFILE "$line";
    }
    system("mv tmp $usrCfgAhbIea");
    close(OUTFILE);
    close(INFILE);
}

foreach my $name (@ahbIeaNames) {
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/active_master_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_enable_tracker(0);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbIea");
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/passive_slave_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_enable_tracker(0);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbIea");
}

#Support for Enabling Strobe Usage in AHB VIP
foreach my $name (@ahbIeaWSTRBNames) {
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/active_master_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_strobe_as_data_phase_signal(1);\\n\\t\\t\tset_deassert_strobe_for_read(1);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbIea");
    
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/passive_slave_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_strobe_as_data_phase_signal(1);\\n\\t\\t\tset_deassert_strobe_for_read(1);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbIea");
}
foreach my $name (@ahbTeaWSTRBNames) {
    my $usrCfgAhbTea = "${testbench}/usr/usr_uvm_cfg/passive_master_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_strobe_as_data_phase_signal(1);\\n\\t\\t\tset_deassert_strobe_for_read(1);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbTea"); 
    
    my $usrCfgAhbTea = "${testbench}/usr/usr_uvm_cfg/active_slave_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_strobe_as_data_phase_signal(1);\\n\\t\\t\tset_deassert_strobe_for_read(1);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbTea"); 
}

# Workaaround for VIP Failure
foreach my $name (@ahbTeaNames) {
    my $usrCfgAhbTea = "${testbench}/usr/usr_uvm_cfg/passive_master_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_enable_tracker(0);\\n\\t\\t\tset_idle_mode_optimization(0);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbTea");
    
    my $usrCfgAhbTea = "${testbench}/usr/usr_uvm_cfg/active_slave_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_enable_tracker(0);\\n\\t\\t\tset_idle_mode_optimization(0);\\n\\\tendfunction: setFieldsValues/g' $usrCfgAhbTea");
}

#Support for Turning Off Extended Memory Types
foreach my $name (@ahbIeaResHPROTNames) {
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/active_master_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_extended_memory_types(0);\\n\\tendfunction: setFieldsValues/g' $usrCfgAhbIea"); 
    
    my $usrCfgAhbIea = "${testbench}/usr/usr_uvm_cfg/passive_slave_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_extended_memory_types(0);\\n\\tendfunction: setFieldsValues/g' $usrCfgAhbIea"); 
}
foreach my $name (@ahbTeaResHPROTNames) {
    my $usrCfgAhbTea = "${testbench}/usr/usr_uvm_cfg/active_slave_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_extended_memory_types(0);\\n\\tendfunction: setFieldsValues/g' $usrCfgAhbTea"); 
    
    my $usrCfgAhbTea = "${testbench}/usr/usr_uvm_cfg/passive_master_${topMod}_${name}_config_usr.sv";
    system("sed -i 's/endfunction: setFieldsValues/\\t\\tset_extended_memory_types(0);\\n\\tendfunction: setFieldsValues/g' $usrCfgAhbTea"); 
}

my $multiClk = 0;
foreach my $clk (@clkNames) {
    $multiClk = $multiClk + 1;
}
my $multiRst = 0;
foreach my $rst (@rstNames) {
    $multiRst = $multiRst + 1;
}

gen_vf();
#Supported Clock and Reset value change at simulation time.
dut_top();
dut_usr_env();
dut_base_test();
stimulus_after_reset_control();
clk_freq_control();

# To control Rand Response from AHB Slave
if ($ahbTeaCnt > 0) {
  update_tb_ahb_slave_resp_and_wait_states();
}

# To pick sequential IDs for AXI requests for ipc max bandwidth test
if ($axi4IeaCnt > 0) {
  update_tb_axi_ipc_tests();
}
#Temporary workaround for STG bug to append code to populate 'slave_id' for configs with zero AXI TEAs.
if($axi4TeaCnt == 0){
    my $max_bw_test = "tests/ipc_tests/max_bandwidth_test.sv";
    my $ot_sweep_test = "tests/ipc_tests/ot_sweep_test.sv";
    my $min_latency_test = "tests/ipc_tests/min_latency_test.sv";
    slave_id_update_workaround($max_bw_test);
    slave_id_update_workaround($ot_sweep_test);
    slave_id_update_workaround($min_latency_test);
}
# Create a smoke test list
if ($isMesh) {
    system("echo \"all_masters_all_slaves_test  +CDN_STG_MIN_ITEM_COUNT=20+CDN_STG_MAX_ITEM_COUNT=20\" > smoke_list");
}
else {
    system("echo \"all_masters_random_segments_test  +CDN_STG_MIN_ITEM_COUNT=20+CDN_STG_MAX_ITEM_COUNT=20\" > smoke_list");
}

sub parse_ports {
    my $start_interface     = 0;
    my $start_configuration = 0;
    my $injW                = 0;
    my $checkerCnt          = 0;
    my @fileNames           = ("ports.def", "$topMod.pinfo");
    my $curr_ename;
    foreach my $file (@fileNames) {
        if (-e $file) {
            open(PINFO, "$file");
            my @pinfo_lines = <PINFO>;

            foreach my $line (@pinfo_lines) {
                if ($line =~ /Interface:\s*(\S+)/) {
                    $start_interface = 1;
                    $curr_ename      = $1;
                    $curr_ename =~ tr/./_/;
                    next;
                }

                next if ($start_interface == 0);

                if ($line =~ /Class:\s*(\S+)/) {
                    if (!($line =~ /fusaAggrCtrl/ || $line =~ /ADHOC/)) {
                        $start_interface = 0;
                    }
                    next;
                }

                if ($line =~ /checkerCnt\s*=\s*([0-9]+)/) {
                    $fusaConfig{$curr_ename}->{checkerCnt} = $1;
                    next;
                }

                if ($line =~ /injW\s*=\s*([0-9]+)/) {
                    $fusaConfig{$curr_ename}->{injW} = $1;
                    next;
                }
                
                if ($line =~ /^(\S*link\S*)\s*dir\(input\)/) {
                    (my $link = $1) =~ s/\./_/g;
                    push (@isolation_links, $link);
                }

                if ($line =~ /^\s$/) {
                    $start_interface = 0;
                }
            }
            last;
        }
    }
}

sub clog2nz {
    my ($int) = @_;

    my $i = 1;
    while ($i < 64) {
        my $cmp = 1 << $i;
        if ($cmp >= $int) {
            return ($i);
        }
        $i++;
    }
    return (64);
}

sub handle_single_fusa_csv {
    my ($csv, $sig_path_prefix, $prefix_arr) = @_;
    my @prefixes = @{$prefix_arr};
    (my $module = $csv) =~ /([^\/]*)_fusaIF.csv/;
    $module = $1;
    open(CSV, "<$csv") || die "Couldn't open file $csv";
    foreach my $line (<CSV>) {
        my @fusa_details = split(', ', $line);
        next if (scalar(@fusa_details) != 10);
        next if ($fusa_details[0] =~ /Interface Prefix/);
        foreach my $pre (@prefixes) {
            my $bit         = $fusa_details[2];
            my $sig_path    = $fusa_details[3];
            my $clk_grp     = $fusa_details[5];
            my $checkerName = "${pre}${module}_${clk_grp}FusaChecker${bit}";
            my $sigMap      = $fusa_details[9];
            my @signals     = split(' ', $fusa_details[9]);
            my $cerr_pins   = "i_$topMod.${pre}${module}_fusa_${clk_grp}_cErr[${bit}]";
            my $uerr_pins   = "i_$topMod.${pre}${module}_fusa_${clk_grp}_uErr[${bit}]";
            my $errenb_pins = "i_$topMod.${pre}${module}_fusa_${clk_grp}_enbVec[${bit}]";
            my $clk         = "i_$topMod.${clk_grp}";
            my $correctable = ($fusa_details[7] =~ /yes/) ? 1 : 0;
            my $flopChecker = ($sigMap =~ /addr_d1/ && $sigMap =~ /ren_d1/) ? 1 : 0;
            my $addrEcc     = ($sigMap =~ /addr_d1/ && $correctable) ? 1 : 0;
            my @data;
           
            #Generate correct signal path. Replace the first module mentioned in the csv file with the correct prefix 
            $sig_path =~ s/([\S]*?)\./$sig_path_prefix/;
            $sig_path = $pre.$sig_path;
            
            my $fusaChecker = "${sig_path}." . $fusa_details[4];
            my $enable      = "i_$topMod.$fusaChecker.dataValid";

            #remove eccCheck string after sampling the path to fusaChecker
            $sig_path =~ s/\.eccCheck[\S]*$//;
            my $width = 0;
            my $awidth = 0;
            foreach $sig (@signals) {
                my $sig_width = 0;
                $sig_width++;
                if ($sig =~ /\[([0-9]*):([0-9]*)\]/) {
                    $sig_width += $1 - $2;
                }
                $width += $sig_width;
                if ($addrEcc && $sig =~ /addr_d1/) {
                    $awidth += $sig_width;
                }
                my $prefix = $flopChecker ? "_s_" : "";
                push(@data, "i_$topMod.$sig_path.${prefix}${sig}");
            }

            my $data_in = "{" . join(',', @data) . "}";
            my $cwidth  = clog2nz($width + 1);
            my $dwidth  = $width - $awidth - $cwidth;

            $fusaCheckerConfig{$checkerName} = {
                'clk'         => $clk,
                'cErrPin'     => $cerr_pins,
                'uErrPin'     => $uerr_pins,
                'errEnbPin'   => $errenb_pins,
                'data'        => $data_in,
                'ecc'         => $correctable,
                'width'       => $width,
                'dwidth'      => $dwidth,
                'cwidth'      => $cwidth,
                'awidth'      => $awidth,
                'flopChecker' => $flopChecker,
                'enable'      => $enable
            };
        }
    }
}

sub parse_fusa_checkers {

    my @csv_hDomains = ('');
    if ((scalar @hDomains) > 1) {
        push(@csv_hDomains, @hDomains);
    }
    my @fusa_csvs;

    foreach my $hDomain (@csv_hDomains) {
        if ($hDomain eq '') {
            if (-e "$cfg_dir/${topMod}_fusaIF.csv") {
                handle_single_fusa_csv("$cfg_dir/${topMod}_fusaIF.csv", '', ['']);
            }
        }
        else {
            if (-e "${cfg_dir}/${topMod}${hDomain}/${topMod}${hDomain}_fusaIF.csv") {
                my $sig_path_prefix = "${hDomain}.";
                handle_single_fusa_csv("${cfg_dir}/${topMod}${hDomain}/${topMod}${hDomain}_fusaIF.csv", $sig_path_prefix, ['']);
            }
        }
        if (-e "${cfg_dir}/${topMod}${hDomain}Core/${topMod}${hDomain}Core_fusaIF.csv") {
            my $sig_path_prefix = (($hDomain ne '')? "${hDomain}.":"") ."${topMod}${hDomain}.";
            handle_single_fusa_csv("${cfg_dir}/${topMod}${hDomain}Core/${topMod}${hDomain}Core_fusaIF.csv", $sig_path_prefix, ['']);
        }
    }

    foreach my $tileType (keys %tileTypes) {
        if (-e "${cfg_dir}/${tileType}/${tileType}_fusaIF.csv") {
            my @tilePlaces = map("${_}_", @{ $tileTypes{$tileType} });
            my $sig_path_prefix = "${tileType}.";
            handle_single_fusa_csv("${cfg_dir}/${tileType}/${tileType}_fusaIF.csv", $sig_path_prefix, \@tilePlaces);
        }
        if (-e "${cfg_dir}/${tileType}Core/${tileType}Core_fusaIF.csv") {
            my @tilePlaces = map("${_}_", @{ $tileTypes{$tileType} });
            my $sig_path_prefix = "${tileType}.${tileType}.";
            handle_single_fusa_csv("${cfg_dir}/${tileType}Core/${tileType}Core_fusaIF.csv", $sig_path_prefix, \@tilePlaces);
        }
    }
}

sub fusa_updates {
    my $topModule = "${testbench}/dut_${topMod}.sv";
    my $start     = 0;
    open(INFILE,  "<$topModule");
    open(OUTFILE, ">tmp");

    foreach my $line (<INFILE>) {
        my $pre_addition  = '';
        my $post_addition = '';
        if ($line =~ /module dut_${topMod}/) { $start = 1; }
        if (($line =~ /initial begin/) && $start) {
            foreach $fusaAggr (keys %fusaConfig) {
                my $injW       = $fusaConfig{$fusaAggr}->{injW};
                my $checkerCnt = $fusaConfig{$fusaAggr}->{checkerCnt};
                $pre_addition .= "   wire [$injW-1:0] ${fusaAggr}_injMask;\n";
                $pre_addition .= "   logic [$injW-1:0] ${fusaAggr}_injMask_force;\n";
                $pre_addition .= "   wire [$checkerCnt-1:0] ${fusaAggr}_injVec;\n";
                $pre_addition .= "   logic [$checkerCnt-1:0] ${fusaAggr}_injVec_force;\n";
                $pre_addition .= "   wire [$checkerCnt-1:0] ${fusaAggr}_enbVec;\n";
                my $fusa_ctrl = <<"FUSA_CTRL";
       if(\$value\$plusargs("${fusaAggr}_injMask_force=%0d", ${fusaAggr}_injMask_force)) begin
           force ${fusaAggr}_injMask = ${fusaAggr}_injMask_force;
       end
       else if (\$test\$plusargs("random_injMask")) begin
           ${fusaAggr}_injMask_force = $injW\'b0;
           for (int i=0; i<$injW; ++i) begin
               ${fusaAggr}_injMask_force |= (\$urandom_range(0,1)<<i);
           end
           force ${fusaAggr}_injMask = ${fusaAggr}_injMask_force;
       end
       else begin
           force ${fusaAggr}_injMask = ${injW}\'b0;
       end
       if(\$value\$plusargs("${fusaAggr}_injVec_force=%0d", ${fusaAggr}_injVec_force)) begin
           force ${fusaAggr}_injVec = ${fusaAggr}_injVec_force;
       end
       else if (\$test\$plusargs("random_injVec")) begin
           ${fusaAggr}_injVec_force = $checkerCnt\'b0;
           for (int i=0; i<$checkerCnt; ++i) begin
               ${fusaAggr}_injVec_force |= (\$urandom_range(0,1)<<i);
           end
           force ${fusaAggr}_injVec = ${fusaAggr}_injVec_force;
       end
       else begin
           force ${fusaAggr}_injVec = ${checkerCnt}\'b0;
       end
       force ${fusaAggr}_enbVec = {${checkerCnt}{1'b1}};
FUSA_CTRL

                $post_addition .= $fusa_ctrl;
            }
            $start = 0;
            print OUTFILE "$pre_addition";
            print OUTFILE "$line";
            print OUTFILE "$post_addition";
        }
        elsif (($line =~ /${topMod} i_${topMod}/)) {
            foreach my $fusaAggr (keys %fusaConfig) {
                my $injW       = $fusaConfig{$fusaAggr}->{injW};
                my $checkerCnt = $fusaConfig{$fusaAggr}->{checkerCnt};
                $post_addition .= "\t\t.${fusaAggr}_injMask(${fusaAggr}_injMask),\n";
                $post_addition .= "\t\t.${fusaAggr}_injVec(${fusaAggr}_injVec),\n";
                $post_addition .= "\t\t.${fusaAggr}_enbVec(${fusaAggr}_enbVec),\n";
            }
            print OUTFILE "$line";
            print OUTFILE "$post_addition";
        }
        elsif ($line =~ /function.*configure_virtual_interfaces/) {
            $post_addition .= "\n";
            $post_addition .= "`ifndef GATE\n";
            $post_addition .= "\t//setting virtual interfaces for memory error injector and monitor for all of the fusaCheckers\n";
            foreach my $checker (keys %fusaCheckerConfig) {
                my $width = $fusaCheckerConfig{$checker}->{'width'};
                $post_addition .= "\tuvm_pkg::uvm_config_db#(virtual memerr_interface #(.DATA_WIDTH(${width})))::set(null, \"*${checker}_*\", \"vif\", ${checker}_if);\n";
            }
            $post_addition .= "\n";
            $post_addition .= "`endif //GATE\n";
            print OUTFILE "$line";
            print OUTFILE "$post_addition";

        }
        else {
            print OUTFILE "$line";
        }
    }
    close(INFILE);
    close(OUTFILE);
    system("mv tmp $topModule");

    my $preExtension = "${testbench}/usr/usr_hdl_extensions/dut_${topMod}_usr_tb_pre_extensions.sv";
    open(OUTFILE, ">$preExtension");
    my $fusa_checker = <<"FUSA_CHECKER";
interface memerr_interface (input wire clk);
	parameter DATA_WIDTH = 32;
    logic [DATA_WIDTH-1: 0] data;
    logic [DATA_WIDTH-1: 0] forceval;
    logic [DATA_WIDTH-1: 0] enForce;
    logic cError;
    logic uError;
    logic errEnb;
    logic readEn;

    function void force_data(logic [DATA_WIDTH-1:0] val);
        forceval = val;
        enForce = 1\'b1;
    endfunction

    function void release_data();
        enForce = 1\'b0;
    endfunction
endinterface

FUSA_CHECKER

    print OUTFILE "$fusa_checker";
    close(OUTFILE);

    my $tb_connections = "${testbench}/usr/usr_hdl_extensions/dut_${topMod}_usr_tb_connections.sv";
    open(OUTFILE, ">$tb_connections");
    print OUTFILE "`ifndef GATE\n";
    foreach my $checker (keys %fusaCheckerConfig) {
        my $width  = $fusaCheckerConfig{$checker}->{'width'};
        my $clk    = $fusaCheckerConfig{$checker}->{'clk'};
        my $data   = $fusaCheckerConfig{$checker}->{'data'};
        my $cError = $fusaCheckerConfig{$checker}->{'cErrPin'};
        my $uError = $fusaCheckerConfig{$checker}->{'uErrPin'};
        my $errEnb = $fusaCheckerConfig{$checker}->{'errEnbPin'};
        my $readEn = $fusaCheckerConfig{$checker}->{'enable'};
        print OUTFILE "\n\n";
        print OUTFILE "\tmemerr_interface #($width) ${checker}_if (.clk($clk));\n\n";
        print OUTFILE "\talways @(*) \n";
        print OUTFILE "\t\tif (${checker}_if.enForce) force ${data} = ${checker}_if.forceval; else release ${data};\n\n";
        print OUTFILE "\tassign ${checker}_if.data = $data;\n";
        print OUTFILE "\tassign ${checker}_if.cError = $cError;\n";
        print OUTFILE "\tassign ${checker}_if.uError = $uError;\n";
        print OUTFILE "\tassign ${checker}_if.errEnb = $errEnb;\n";
        print OUTFILE "\tassign ${checker}_if.readEn = $readEn;\n";
        print OUTFILE "\n\n";
    }
    print OUTFILE "`endif //GATE\n";
    close(OUTFILE);


    my $memerr_env = "${testbench}/usr/memory_error_env.sv";
    open(OUTFILE, ">$memerr_env");
    
    my $memerr_inj = <<"MEMERR_INJ";
class memerr_info extends uvm_object;
   `uvm_object_utils(memerr_info)

   bit is_correctable = 1\'b0;

   function new(string name = "base_usr_sample_vseq");
      super.new(name);
   endfunction

endclass

class memerr_injector #(int ADDR_WIDTH=0, int DATA_WIDTH=32, int CHECKDATA_WIDTH=7, bit ECC=1\'b1) extends uvm_component; //{
   `uvm_component_utils(memerr_injector#(ADDR_WIDTH, DATA_WIDTH, CHECKDATA_WIDTH, ECC))

    int freq_cerr = 0;
    int freq_uerr = 0;
    int freq_perr = 0;
    
    uvm_analysis_port #(memerr_info) error_info;
    virtual memerr_interface #(ADDR_WIDTH+DATA_WIDTH+CHECKDATA_WIDTH) vif;

    function new(string name = "memerr_injector", uvm_component parent = null);
        super.new(name, parent);
        if (\$value\$plusargs("cErrFreq=%d", freq_cerr)) begin //{
        end //}
        if (\$value\$plusargs("uErrFreq=%d", freq_uerr)) begin //{
        end //}
        if (\$value\$plusargs("pErrFreq=%d", freq_perr)) begin //{
        end //}
        error_info = new("error_info", this);
    endfunction

   
    virtual function int get_bit (bit use_eccbits, bit use_addrbits, bit use_allbits, int old_bit = 0, bit no_repeat=1\'b1);
        bit done=1\'b0;
        int curr_bit;

        while (!done) begin
            curr_bit = use_addrbits ? \$urandom_range(DATA_WIDTH+CHECKDATA_WIDTH, DATA_WIDTH+CHECKDATA_WIDTH+ADDR_WIDTH-1):
                       use_eccbits  ? \$urandom_range(DATA_WIDTH, DATA_WIDTH+CHECKDATA_WIDTH-1) : 
                       use_allbits  ? \$urandom_range(0, DATA_WIDTH+CHECKDATA_WIDTH+ADDR_WIDTH-1) : 
                       \$urandom_range(0, DATA_WIDTH+CHECKDATA_WIDTH-1);
            done = no_repeat ? (old_bit != curr_bit) : 1\'b1;
        end
        return curr_bit;
    endfunction

    virtual function bit inject_memerr(int freq); //{
        //for some reason flop output release is not working. After forcing some value, it carries the value even after release till clock is activated.
        //In this case a second force would actually take away the error and the monitor fails.
        //To ensure each force will lead to an error we will only inject errors on flops if there are no errors at present.
        return ((\$urandom_range(1,1000000) <= freq) && !(!ECC && vif.uError));
    endfunction: inject_memerr //}

    virtual function void build_phase(uvm_phase phase);
       super.build_phase(phase);
       if (!uvm_config_db #(virtual memerr_interface #(ADDR_WIDTH+DATA_WIDTH+CHECKDATA_WIDTH))::get(this, "", "vif", vif)) begin
          \`uvm_error("NOVIF", {"virtual interface not configured for ", get_full_name(), ".vif"})
       end           
    endfunction: build_phase

    task run_phase(uvm_phase phase); //{
        bit [ADDR_WIDTH+DATA_WIDTH+CHECKDATA_WIDTH-1:0] value;
        bit [ADDR_WIDTH+DATA_WIDTH+CHECKDATA_WIDTH-1:0] mask;
        bit inject_single;
        bit inject_double;
        bit inject_addr;
        bit is_correctable;
        int which_bit;
        int double_bit;
        memerr_info error_tx;

        //wait for 200 cycles for reset
        repeat (200) @(posedge vif.clk);

        forever begin //{ 
            @(posedge vif.clk);
            vif.release_data(); 
            @(negedge vif.clk);
            inject_single = ECC ? inject_memerr(freq_cerr) : inject_memerr(freq_perr);
            inject_double = ECC ? inject_memerr(freq_uerr) : 0;
            inject_addr = ECC && ADDR_WIDTH>0 ? inject_memerr(freq_uerr) : 0;
            if (vif.readEn && vif.errEnb && inject_single) begin //{
                if (inject_addr) begin
                    which_bit = get_bit(1\'b0, 1\'b1, 1\'b0, 0, 1\'b0);
                    mask = 1\'b1 << which_bit;
                    is_correctable = 1\'b0;
                end
                else begin
                    which_bit = get_bit(1\'b0, 1\'b0, 1\'b0, 0, 1\'b0);
                    mask = 1\'b1 << which_bit;
                    is_correctable = ECC ? 1\'b1 : 1\'b0;
                    \`uvm_info("", \$sformatf("injecting single bit error at %d", which_bit), UVM_DEBUG)
                    if (inject_double) begin
                        double_bit = get_bit(1\'b0, 1\'b0, 1\'b1, which_bit, 1\'b1);
                        mask |= 1\'b1 << double_bit;
                        \`uvm_info("", \$sformatf("injecting double bit error at %d", double_bit), UVM_NONE)
                        is_correctable = 1\'b0;
                    end
                end
                value = vif.data ^ mask;
                vif.force_data(value);
                
                error_tx = memerr_info::type_id::create("error_tx");
                error_tx.is_correctable = is_correctable;
                error_info.write(error_tx);
            end //}
        end //}
    endtask //}
endclass : memerr_injector //}

MEMERR_INJ

    print OUTFILE $memerr_inj;

    my $memerr_mon = <<"MEMERR_MON";
class memerr_monitor #(int ADDR_WIDTH=0, int DATA_WIDTH=32, int CHECKDATA_WIDTH=7, bit ECC=1\'b1) extends uvm_component; //{
   \`uvm_component_utils(memerr_monitor#(ADDR_WIDTH, DATA_WIDTH, CHECKDATA_WIDTH, ECC))

    uvm_analysis_port #(memerr_info) error_info;
    uvm_analysis_imp #(memerr_info, memerr_monitor#(ADDR_WIDTH, DATA_WIDTH, CHECKDATA_WIDTH, ECC)) error_info_imp;
    
    virtual memerr_interface #(ADDR_WIDTH+DATA_WIDTH+CHECKDATA_WIDTH) vif;
    
    function new(string name = "memerr_monitor", uvm_component parent = null);
        super.new(name, parent);
        error_info_imp = new("error_info_imp", this);
    endfunction

    virtual function void build_phase(uvm_phase phase);
       super.build_phase(phase);
       if (!uvm_config_db #(virtual memerr_interface #(ADDR_WIDTH+DATA_WIDTH+CHECKDATA_WIDTH))::get(this, "", "vif", vif)) begin
          \`uvm_error("NOVIF", {"virtual interface not configured for ", get_full_name(), ".vif"})
       end           
    endfunction: build_phase

    virtual function void write (memerr_info error_tx);
        fork 
            begin
                //we forcing the checker input and error indication outputs are registered so wait for 2 cycles after injection
                \@(posedge vif.clk);
                \@(posedge vif.clk); 
                if (error_tx.is_correctable) begin
                    if (!vif.cError || vif.uError) begin
                        `uvm_error(get_full_name(), \$sformatf("Correctectable error is expected but the pin indication is not correct: cErr=%b, uErr=%b", vif.cError, vif.uError))
                    end
                end
                else begin
                    if (!vif.uError || vif.cError) begin
                        `uvm_error(get_full_name(), \$sformatf("Uncorrectectable error is expected but the pin indication is not correct: cErr=%b, uErr=%b", vif.cError, vif.uError))
                    end
                end
            end
        join_none
    endfunction

endclass : memerr_monitor//}
    
MEMERR_MON
    
    print OUTFILE $memerr_mon;

    print OUTFILE "class memory_error_env extends uvm_env; //{\n";
    print OUTFILE "\t\`uvm_component_utils(memory_error_env)\n";
    
    foreach my $checker (keys %fusaCheckerConfig) {
        my $dwidth  = $fusaCheckerConfig{$checker}->{'dwidth'};
        my $cwidth  = $fusaCheckerConfig{$checker}->{'cwidth'};
        my $awidth  = $fusaCheckerConfig{$checker}->{'awidth'};
        my $ecc    = $fusaCheckerConfig{$checker}->{'ecc'} ? "1\'b1" : "1\'b0";
        print OUTFILE "\tmemerr_injector#(.ADDR_WIDTH(${awidth}), .DATA_WIDTH(${dwidth}), .CHECKDATA_WIDTH(${cwidth}), .ECC(${ecc})) ${checker}_injector;\n";
        print OUTFILE "\tmemerr_monitor#(.ADDR_WIDTH(${awidth}), .DATA_WIDTH(${dwidth}), .CHECKDATA_WIDTH(${cwidth}), .ECC(${ecc})) ${checker}_monitor;\n";
    }

    print OUTFILE "\tfunction new(string name = \"memerr_env\", uvm_component parent = null);\n";
    print OUTFILE "\t\tsuper.new(name, parent);\n";
    print OUTFILE "\tendfunction\n";

    print OUTFILE "\tvirtual function void build_phase(uvm_phase phase);\n";
    print OUTFILE "\t\tsuper.build_phase(phase);\n";
    print OUTFILE "\t`ifndef GATE\n";
    foreach my $checker (keys %fusaCheckerConfig) {
        my $dwidth  = $fusaCheckerConfig{$checker}->{'dwidth'};
        my $cwidth  = $fusaCheckerConfig{$checker}->{'cwidth'};
        my $awidth  = $fusaCheckerConfig{$checker}->{'awidth'};
        my $ecc    = $fusaCheckerConfig{$checker}->{'ecc'} ? "1\'b1" : "1\'b0";
        print OUTFILE "\t\t${checker}_injector = memerr_injector#(.ADDR_WIDTH(${awidth}), .DATA_WIDTH(${dwidth}), .CHECKDATA_WIDTH(${cwidth}), .ECC(${ecc}))::type_id::create(\"${checker}_injector\", this);\n";
        print OUTFILE "\t\t${checker}_monitor = memerr_monitor#(.ADDR_WIDTH(${awidth}), .DATA_WIDTH(${dwidth}), .CHECKDATA_WIDTH(${cwidth}), .ECC(${ecc}))::type_id::create(\"${checker}_monitor\", this);\n";
    }
    print OUTFILE "\t`endif //GATE\n";
    print OUTFILE "\tendfunction\n";


    print OUTFILE "\tvirtual function void connect_phase(uvm_phase phase);\n";
    print OUTFILE "\t\tsuper.connect_phase(phase);\n";
    print OUTFILE "\t`ifndef GATE\n";
    foreach my $checker (keys %fusaCheckerConfig) {
        print OUTFILE "\t\t${checker}_injector.error_info.connect(${checker}_monitor.error_info_imp);\n";
    }
    print OUTFILE "\t`endif //GATE\n";
    print OUTFILE "\tendfunction\n";
    print OUTFILE "endclass //}\n";

    close(OUTFILE);

    my $usrPkg = "${testbench}/usr/dut_${topMod}_usr_pkg.sv";
    system("sed -i 's/\`include \"dut_${topMod}_usr_env.sv\"/\`include \"memory_error_env.sv\"\\n\`include \"dut_${topMod}_usr_env.sv\"/g' $usrPkg");

    my $usrEnv = "${testbench}/usr/dut_${topMod}_usr_env.sv";
    open(INFILE,  "<$usrEnv");
    open(OUTFILE,  ">tmp");
    foreach my $line (<INFILE>) {
        my $pre_addition  = '';
        my $post_addition = '';
        if (($line =~ /component_util.*dut_${topMod}_env_scoreboard_agent_user/)) {
            $post_addition .= "\t\tmemory_error_env memerr_env;\n\n";
            $post_addition .= "\t\tvirtual function void build_phase(uvm_phase phase);\n";
            $post_addition .= "\t\t\tsuper.build_phase(phase);\n";
            $post_addition .= "\t\t\tmemerr_env = memory_error_env::type_id::create(\"memerr_env\", this);\n";
            $post_addition .= "\t\tendfunction\n\n";
        }
        print OUTFILE "$line";
        print OUTFILE "$post_addition";
    }
    close(INFILE);
    close(OUTFILE);
    system("mv tmp $usrEnv");

}

#Issue: The parsing is very crude and would fail if STG changes something (quite likely with the version update)
sub update_usr_tb {
    my $perDataRstatus_present = ($perDataRstatus == 1);
    my $AceLitePresent = ($AceLitePresent == 1);
    my $axi4_present           = ($axi4IeaCnt > 0 || $axi4TeaCnt > 0 || $axi4p);
    my $apb_present            = ($apbIeaCnt > 0 || $apbTeaCnt > 0);
    my $ahb_present            = ($ahbIeaCnt > 0 || $ahbTeaCnt > 0);

    if ($axi4_present || $apb_present || $ahb_present) {
        my $usrtb = "${testbench}/usr/dut_${topMod}_usr_tb.sv";
        my $usrcache_const     = 0;
        open(INFILE,  "<$usrtb");
        foreach my $line (<INFILE>) {
            if ($line =~ /constraint usrCacheable \{/) {
               $usrcache_const     = 1;
            }
        }
        close(INFILE);

        open(INFILE,  "<$usrtb");
        open(OUTFILE, ">tmp");

        my $in_usr_axi_tx      = 0;
        my $in_usr_ahb_tx      = 0;
        my $in_usr_apb_tx      = 0;
        my $set_slave_callback = 0;
        my $set_UpdateErrorcontrol = 0;
        my $set_UpdateErrorcontrol_ahb_a = 0;
        my $set_UpdateErrorcontrol_ahb_b = 0;
        my $set_master_callback = 0;
        my $axi_ini_cnst       = 0;
        my $axi_ini_cnst_add   = 0;
        my $apb_ini_cnst       = 0;
        my $apb_add_rw_logic   = 0;

        foreach my $line (<INFILE>) {
            my $pre_addition  = '';
            my $pre_addition1  = '';
            my $pre_addition2  = '';
            my $post_addition = '';
            if ($line =~ /class axiTransactionUsr extends cdnStg_axiTransaction/) {
                $in_usr_axi_tx = 1;
            }
            if ($line =~ /class ahbTransactionUsr extends cdnStg_ahbTransaction/) {
                $in_usr_ahb_tx = 1;
            }
            if ($line =~ /class apbTransactionUsr extends cdnStg_apbTransaction/) {
                $in_usr_apb_tx = 1;
            }
	    if($line =~ /uvm_object_utils/ && $in_usr_ahb_tx){
		$pre_addition = <<"END_ADD";
	typedef enum {ZERO,LOW,MEDIUM,HIGH,CUSTOM} delay_type;
	rand delay_type delay_type_c;
	string cmdline_delay_type="";
	string custom_delays, custom_resp_delays;
	rand int min_delay, max_delay, min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay, num_transfers;
	int cmdline_delay_min, cmdline_delay_max, cmdline_min_inter_resp_delay, cmdline_max_inter_resp_delay, cmdline_min_intra_resp_delay, cmdline_max_intra_resp_delay, custom_resp_delay_range, custom_delay_range, custom_delay_type;
END_ADD
		print OUTFILE "$pre_addition";
		$pre_addition='';		
            }
	    if($line =~ /uvm_object_utils/ && $in_usr_apb_tx){
		$pre_addition = <<"END_ADD";
	typedef enum {ZERO,LOW,MEDIUM,HIGH,CUSTOM} delay_type;
	rand delay_type delay_type_c;
	string cmdline_delay_type="";
	string custom_delays;
	rand int min_delay, max_delay;
	int cmdline_delay_min, cmdline_delay_max, custom_delay_range, custom_delay_type;
END_ADD
		print OUTFILE "$pre_addition";
		$pre_addition='';		
            }
	    if($line =~ /uvm_object_utils/ && $in_usr_axi_tx){
		$pre_addition = <<"END_ADD";
	typedef enum {ZERO,LOW,MEDIUM,HIGH,CUSTOM} delay_type;
	rand delay_type delay_type_c;
	string cmdline_delay_type="";
	string custom_delays, custom_resp_delays;
	rand int min_delay, max_delay, min_ready_delay, max_ready_delay, min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay, num_transfers;
	int cmdline_delay_min, cmdline_delay_max, cmdline_min_inter_resp_delay, cmdline_max_inter_resp_delay, cmdline_min_intra_resp_delay, cmdline_max_intra_resp_delay, custom_resp_delay_range, custom_delay_range, custom_delay_type;
    bit is_active_slave = 1'b0;
END_ADD
		print OUTFILE "$pre_addition";
		$pre_addition='';		
            }
	    if ($line =~ /endfunction : new/ && $in_usr_ahb_tx) {
              print OUTFILE "\t\tthis.incr_size_constraint.constraint_mode(0);\n";  
              print OUTFILE "\t\tthis.hmaster.constraint_mode(0);\n";
              print OUTFILE "\t\tif(\$test\$plusargs(\"incr_undef_enabled\")) begin\n";
              print OUTFILE "\t\t\tthis.usrKindIncrUndef_c.constraint_mode(0);\n";
              print OUTFILE "\t\tend\n";
	      print OUTFILE "\t\t//Disabling VIP constraints for AHB delays and randomizing for our usage\n";
	      $pre_addition = <<"END_ADD";
		this.transmitDelayConstraint.constraint_mode(0);
		this.retryDelayConstraint.constraint_mode(0);
		this.deassertRequestDelayConstraint.constraint_mode(0);
		this.splitDelayConstraint.constraint_mode(0);
		this.burstDelayConstraint.constraint_mode(0);
		this.lastBusyDelayConstraint.constraint_mode(0);
		this.transfersBusyDelayConstraint.constraint_mode(0);
		this.transfersSplitDelayConstraint.constraint_mode(0);
		this.transfersResponsesBusyDelayLengthConstraint.constraint_mode(0);
		if((\$value\$plusargs("CUSTOM_AHB_RESP_DELAY_RANGE=%s",custom_resp_delays)) || (\$value\$plusargs("CUSTOM_RESP_DELAY_RANGE=%s",custom_resp_delays))) begin
			 if(\$sscanf(custom_resp_delays,"%d:%d:%d:%d",cmdline_min_inter_resp_delay, cmdline_max_inter_resp_delay, cmdline_min_intra_resp_delay, cmdline_max_intra_resp_delay)) begin 
				this.min_inter_resp_delay.rand_mode(0);
				this.max_inter_resp_delay.rand_mode(0);
				this.min_intra_resp_delay.rand_mode(0);
				this.max_intra_resp_delay.rand_mode(0);

				min_inter_resp_delay=cmdline_min_inter_resp_delay;
				max_inter_resp_delay=cmdline_max_inter_resp_delay;
				min_intra_resp_delay=cmdline_min_intra_resp_delay;
				max_intra_resp_delay=cmdline_max_intra_resp_delay;
			 end else \$display("Incorrect way to provide custom range for resp delay");
			 custom_resp_delay_range=1;
		 end else begin
			 custom_resp_delay_range=0;
		 end
		 
		 if((\$value\$plusargs("AHB_DELAY_TYPE=%s",cmdline_delay_type)) || (\$test\$plusargs("CUSTOM_AHB_DELAY_RANGE")) || (\$value\$plusargs("DELAY_TYPE=%s",cmdline_delay_type)) || (\$test\$plusargs("CUSTOM_DELAY_RANGE"))) begin 
		     this.delay_type_c.rand_mode(0);
		     if((\$value\$plusargs("CUSTOM_AHB_DELAY_RANGE=%s",custom_delays)) || (\$value\$plusargs("CUSTOM_DELAY_RANGE=%s",custom_delays))) begin
			 if(\$sscanf(custom_delays,"%d:%d",cmdline_delay_min,cmdline_delay_max)) begin 
				this.min_delay.rand_mode(0);
				this.max_delay.rand_mode(0);
				min_delay=cmdline_delay_min;
				max_delay=cmdline_delay_max;
			 end else \$display("Incorrect way to provide custom range");
			 custom_delay_range=1;
			 delay_type_c = CUSTOM;
		     end else begin
			custom_delay_range=0;
			if((\$value\$plusargs("AHB_DELAY_TYPE=%s",cmdline_delay_type)) || (\$value\$plusargs("DELAY_TYPE=%s",cmdline_delay_type))) begin
			    custom_delay_type=1;		
			    if(cmdline_delay_type == "HIGH") delay_type_c = HIGH;
			    else if(cmdline_delay_type == "MEDIUM") delay_type_c = MEDIUM;
			    else if(cmdline_delay_type == "ZERO") delay_type_c = ZERO;
			    else delay_type_c = LOW;
			end else custom_delay_type=0;
		     end 
		 end 
END_ADD
            }
	    if ($line =~ /endfunction : new/ && $in_usr_apb_tx) {
            my $allow_unaligned = ($pkt_Version>1) ? "this.address_aligned_const.constraint_mode(0);" : "";

                $pre_addition = <<"END_ADD";
		 $allow_unaligned
         //Disable delay constraints in VIP and use custom range
		 //Not randomizing Delay and ReqDelay fields as those aren't required
		 this.max_req_response_delay.constraint_mode(0);
		 		 
		 if((\$value\$plusargs("APB_DELAY_TYPE=%s",cmdline_delay_type)) || (\$test\$plusargs("CUSTOM_APB_DELAY_RANGE")) || (\$value\$plusargs("DELAY_TYPE=%s",cmdline_delay_type)) || (\$test\$plusargs("CUSTOM_DELAY_RANGE"))) begin 
		     this.delay_type_c.rand_mode(0);
		     if((\$value\$plusargs("CUSTOM_APB_DELAY_RANGE=%s",custom_delays)) || (\$value\$plusargs("CUSTOM_DELAY_RANGE=%s",custom_delays))) begin
			 if(\$sscanf(custom_delays,"%d:%d",cmdline_delay_min,cmdline_delay_max)) begin 
				this.min_delay.rand_mode(0);
				this.max_delay.rand_mode(0);
				min_delay=cmdline_delay_min;
				max_delay=cmdline_delay_max;
			 end else \$display("Incorrect way to provide custom range");
			 custom_delay_range=1;
			 delay_type_c = CUSTOM;
		     end else begin
			custom_delay_range=0;
			if((\$value\$plusargs("APB_DELAY_TYPE=%s",cmdline_delay_type)) || (\$value\$plusargs("DELAY_TYPE=%s",cmdline_delay_type))) begin
			    custom_delay_type=1;		
			    if(cmdline_delay_type == "HIGH") delay_type_c = HIGH;
			    else if(cmdline_delay_type == "MEDIUM") delay_type_c = MEDIUM;
			    else if(cmdline_delay_type == "ZERO") delay_type_c = ZERO;
			    else delay_type_c = LOW;
			end else custom_delay_type=0;
		     end 
		 end
END_ADD
		print OUTFILE "$pre_addition";
		$pre_addition='';
	    }
            if ($line =~ /endfunction : new/ && $in_usr_axi_tx) {
                $axi_ini_cnst = 1;
                $pre_addition = <<"END_ADD";
  
		 //Disable delay constraints in VIP and use custom ranges
		 this.max_delay_write_address_offset_default_value_const.constraint_mode(0);
		 this.enforce_write_address_offset_default_value_const.constraint_mode(0);
		 this.TransmitDelay_const.constraint_mode(0);
		 this.delay_timing_const_ChannelDelay.constraint_mode(0);
		 this.delay_timing_const_AddressDelay.constraint_mode(0);
		 this.delay_timing_const_TransmitDelay.constraint_mode(0);
		 this.delay_timing_const_BreadyDelay.constraint_mode(0);
		 this.TransfersChannelDelay_defaultTiming_const.constraint_mode(0);

		 if((\$value\$plusargs("CUSTOM_AXI_RESP_DELAY_RANGE=%s",custom_resp_delays)) || (\$value\$plusargs("CUSTOM_RESP_DELAY_RANGE=%s",custom_resp_delays))) begin
			 if(\$sscanf(custom_resp_delays,"%d:%d:%d:%d",cmdline_min_inter_resp_delay, cmdline_max_inter_resp_delay, cmdline_min_intra_resp_delay, cmdline_max_intra_resp_delay)) begin 
				this.min_inter_resp_delay.rand_mode(0);
				this.max_inter_resp_delay.rand_mode(0);
				this.min_intra_resp_delay.rand_mode(0);
				this.max_intra_resp_delay.rand_mode(0);

				min_inter_resp_delay=cmdline_min_inter_resp_delay;
				max_inter_resp_delay=cmdline_max_inter_resp_delay;
				min_intra_resp_delay=cmdline_min_intra_resp_delay;
				max_intra_resp_delay=cmdline_max_intra_resp_delay;
			 end else \$display("Incorrect way to provide custom range for resp delay");
			 custom_resp_delay_range=1;
		 end else begin
			 custom_resp_delay_range=0;
		 end
		 
		 if((\$value\$plusargs("AXI_DELAY_TYPE=%s",cmdline_delay_type)) || (\$test\$plusargs("CUSTOM_AXI_DELAY_RANGE")) || (\$value\$plusargs("DELAY_TYPE=%s",cmdline_delay_type)) || (\$test\$plusargs("CUSTOM_DELAY_RANGE"))) begin 
		     this.delay_type_c.rand_mode(0);
		     if((\$value\$plusargs("CUSTOM_AXI_DELAY_RANGE=%s",custom_delays)) || (\$value\$plusargs("CUSTOM_DELAY_RANGE=%s",custom_delays))) begin
			 if(\$sscanf(custom_delays,"%d:%d",cmdline_delay_min,cmdline_delay_max)) begin 
				this.min_delay.rand_mode(0);
				this.max_delay.rand_mode(0);
				this.min_ready_delay.rand_mode(0);
				this.max_ready_delay.rand_mode(0);
				min_delay=cmdline_delay_min;
				max_delay=cmdline_delay_max;
				min_ready_delay=cmdline_delay_min;
				max_ready_delay=cmdline_delay_max;
			 end else \$display("Incorrect way to provide custom range");
			 custom_delay_range=1;
			 delay_type_c = CUSTOM;
		     end else begin
			custom_delay_range=0;
			if((\$value\$plusargs("AXI_DELAY_TYPE=%s",cmdline_delay_type)) || (\$value\$plusargs("DELAY_TYPE=%s",cmdline_delay_type))) begin
			    custom_delay_type=1;		
			    if(cmdline_delay_type == "HIGH") delay_type_c = HIGH;
			    else if(cmdline_delay_type == "MEDIUM") delay_type_c = MEDIUM;
			    else if(cmdline_delay_type == "ZERO") delay_type_c = ZERO;
			    else delay_type_c = LOW;
			end else custom_delay_type=0;
		     end 
		 end 
		  
                 //These constraints are disabled by default and enabled using plusargs.                
                 this.usrKindFixed_c.constraint_mode(0);
                 this.usrKindIncr_c.constraint_mode(0);
                 this.usrKindWrap_c.constraint_mode(0);
                 this.usrOkayResponse_c.constraint_mode(0);

                 //Disable aligned constraint, and enable custom constraint for non-supported FIXED Kind
                 this.constraintUnaligned.constraint_mode(0);
                 this.constraintAligned.constraint_mode(0);
                 this.usrConstraintAligned_c.constraint_mode(1);
                 if (\$test\$plusargs("fixed_only")) begin //{
                     this.usrKindFixed_c.constraint_mode(1);
                 end //}     
                 else if (\$test\$plusargs("incr_only")) begin //{
                     this.usrKindIncr_c.constraint_mode(1);
                 end //}     
                 else if (\$test\$plusargs("wrap_only")) begin //{
                     this.usrKindWrap_c.constraint_mode(1);
                 end //} 
                 if (\$test\$plusargs("unaligned_check")) begin //{ // to cover start_addr_offset // transfer size //it should be 1  
	                  this.constraintUnaligned.constraint_mode(1); 
                      this.usrConstraintAligned_c.constraint_mode(0);
	             end //} 	
                 this.region_const.constraint_mode(0);
                 this.forceId0_c.constraint_mode(0);
                 if (\$test\$plusargs("force_single_id")) begin //{ // use single request id  
                    this.forceId0_c.constraint_mode(1);
                 end //}
END_ADD
                 if($usrcache_const) {
                 $pre_addition1 = <<"END_ADD";
                 this.usrCacheable.constraint_mode(1);  // to cover cacheble bit
                 if (\$test\$plusargs("cache_check")) begin //{ // to cover cache transfers.	
	                this.usrCacheable.constraint_mode(0); 
	             end //} 	
                 if (\$test\$plusargs("include_exclusive")) begin //{ // to cover cache transfers.	
                    this.normal_access_const.constraint_mode(0);
                    this.new_normal_access_const.constraint_mode(1);
                 end //}                    
               
END_ADD
                 }   
                 if($AceLitePresent) {
                 $pre_addition2 = <<"END_ADD";
                 this.usrDefault_c.constraint_mode(0);
                 this.usrAce_barrier_c.constraint_mode(0);
                 if (\$test\$plusargs("ace_barrier_check")) begin //{
                  this.usrAce_c.constraint_mode(0);
                  ace_no_barrier_const.constraint_mode(0);
                  this.usrAce_barrier_c.constraint_mode(1);
                 end //}   

                 this.usrAce_ReadSnoop.constraint_mode(0);
                 if (\$test\$plusargs("ace_read_snoop_check")) begin //{
                  this.usrAce_c.constraint_mode(0);
                  ace_no_barrier_const.constraint_mode(0);
                  this.usrAce_ReadSnoop.constraint_mode(1);
                 end //}  
                 this.usrAce_WriteSnoop.constraint_mode(0);
                 if (\$test\$plusargs("ace_write_snoop_check")) begin //{
                  this.usrAce_c.constraint_mode(0);
                  ace_no_barrier_const.constraint_mode(0);
                  this.usrAce_WriteSnoop.constraint_mode(1);
                 end //}
                 this.usrAce_c.constraint_mode(0);
                 this.usrAce_Global.constraint_mode(1);  
END_ADD

                 }   
            }
            if ($line =~ /endclass/ && $in_usr_axi_tx) {
                $axi_ini_cnst_add = 1;
                $pre_addition     = <<"END_ADD";

                function void pre_randomize();
                    super.pre_randomize();
                    if (uvm_pkg::uvm_re_match("active_slave.inst",pInst.get_full_name())==0) begin
                        is_active_slave = 1'b1;
                    end
                    else begin
                        is_active_slave = 1'b0;
                    end
                endfunction : pre_randomize
  
                //constraint to only allow one burst type 
                constraint usrKindFixed_c { 
                    Kind == DENALI_CDN_AXI_BURSTKIND_FIXED;
                }
                constraint usrKindIncr_c { 
                    Kind == DENALI_CDN_AXI_BURSTKIND_INCR;
                }
                constraint usrKindWrap_c { 
                    Kind == DENALI_CDN_AXI_BURSTKIND_WRAP;
                }
                constraint default_resp_is_okay_exokay { 
                 // write response
                    Resp != DENALI_CDN_AXI_RESPONSE_DECERR; 
                    Resp != DENALI_CDN_AXI_RESPONSE_SLVERR; 
                 // read responses
  	                if(Access == DENALI_CDN_AXI_ACCESS_EXCLUSIVE) {
                        foreach (TransfersResp[tfer_id]) { 
                            TransfersResp[tfer_id] == DENALI_CDN_AXI_RESPONSE_EXOKAY;
                        }
                    }
                    else {
                        foreach (TransfersResp[tfer_id]) { 
                            TransfersResp[tfer_id] == DENALI_CDN_AXI_RESPONSE_OKAY;
                        }
                    }
                }
                constraint new_normal_access_const { 
                    Access != DENALI_CDN_AXI_ACCESS_LOCKED;
                }
                constraint userBit {
                   Auser.size() == 1; //we will only wiggle 32 bits at the most. 
                   foreach(Auser[i]) {
                   Auser[i] inside {[0:'hFFFFFFFF]}; // Auser .. here you can add the needed value
                   } 
                   Buser.size() == 1; //we will only wiggle 32 bits at the most. 
                   foreach(Buser[i]) {
                   Buser[i] inside {[0:'hFFFFFFFF]}; // Buser .. here you can add the needed value
                   } 

                   UserSignalArray.size() == Length; //len; // UserSignalArray.size() = trans.Length * (WuserSignalwidth/32)
                   foreach(UserSignalArray[i]) {
                    UserSignalArray[i] inside {[0:'hFFFFFFFF]}; // wUSER .. here you can add the needed value
                   }
                 }
		 constraint usrConstraintAligned_c {
  	         	  if(Access != DENALI_CDN_AXI_ACCESS_EXCLUSIVE) {
                 	       Kind dist { DENALI_CDN_AXI_BURSTKIND_FIXED := 2, DENALI_CDN_AXI_BURSTKIND_INCR := 4, DENALI_CDN_AXI_BURSTKIND_WRAP := 4};
END_ADD
		 if(($pkt_Version == 2) || ($pkt_Version == 3)) {
			$pre_addition     .= <<"END_ADD";					
			       //Packet format 2 and 3 support unalied transfers for fixed burst. So only wrap should have aligned addresses
  	                       if(Kind == DENALI_CDN_AXI_BURSTKIND_WRAP) {  
END_ADD
		 } else {
			$pre_addition     .= <<"END_ADD";
            	               if(Kind != DENALI_CDN_AXI_BURSTKIND_INCR) {                    	  
END_ADD
		 }
		 $pre_addition     .= <<"END_ADD";
					StartAddress % BurstSize == 0;
  	                    		DataByteLength == Length * BurstSize;
  	                       }
                      	       else{
                        		AddressAlignment dist { CDN_STG_ADDRESS_UNALIGNED := 4, CDN_STG_ADDRESS_ALIGNED := 6};
  	                    		DataByteLength == Length * BurstSize;
                      	       }
                   	} 
                 	solve Kind before StartAddress, BurstSize, Length, DataByteLength;
                 	solve AddressAlignment before StartAddress, Size;
                  	solve Length, BurstSize before DataByteLength;
		 }

		 constraint delay_type_constr_c {
			if(custom_delay_type == 0 && custom_delay_range == 0) { 	
				delay_type_c dist {ZERO := 10, LOW:=30, MEDIUM:=30, HIGH:=30, CUSTOM :=0};
			}	
		 }

		 constraint delay_dist_c {
			if(custom_delay_range == 0) {
				if(delay_type_c == HIGH && is_active_slave) {
					min_delay==251;
					max_delay==1023;
					min_ready_delay==26;
					max_ready_delay==50;
				} else if(delay_type_c == MEDIUM && is_active_slave){
					min_delay==51;
					max_delay==250;
					min_ready_delay==11;
					max_ready_delay==25;
				} else if(delay_type_c == LOW && is_active_slave){
					min_delay==0;
					max_delay==50;
					min_ready_delay==0;
					max_ready_delay==10;
				} else if(delay_type_c == ZERO){
					min_delay==0;
					max_delay==0;
					min_ready_delay==0;
					max_ready_delay==0;
				} else{
					min_delay==0;
					max_delay==10;
					min_ready_delay==0;
					max_ready_delay==10;
				}			
            }
		 }

		 constraint resp_delay_range_c {	
			num_transfers == TransfersChannelDelay.size();//Get number of transfer to randomize higher delay for any random transfer and lower for others
			if(custom_resp_delay_range == 0) { 	
                if (Type == DENALI_CDN_AXI_TR_Read) {
				    min_inter_resp_delay == min_delay;
				    max_inter_resp_delay == max_delay;
				    min_intra_resp_delay == (min_delay/num_transfers);
				    //Avoid zero delays when num transfers are high
				    if(max_delay<num_transfers && max_delay!=0){
					    max_intra_resp_delay inside {[1:4]};
				    } else {
					    max_intra_resp_delay == (max_delay/num_transfers);
				    }
                }
                else {
				    min_inter_resp_delay == min_ready_delay;
				    max_inter_resp_delay == max_ready_delay;
				    min_intra_resp_delay == (min_ready_delay/num_transfers);
				    //Avoid zero delays when num transfers are high
				    if(max_ready_delay<num_transfers && max_ready_delay!=0){
					    max_intra_resp_delay inside {[1:4]};
				    } else {
					    max_intra_resp_delay == (max_ready_delay/num_transfers);
				    }
                }
			}
            
            RreadyControl == DENALI_CDN_AXI_READYCONTROL_DELAYED_ASSERTION;
            WreadyControl == DENALI_CDN_AXI_READYCONTROL_DELAYED_ASSERTION;
            BreadyControl == DENALI_CDN_AXI_READYCONTROL_DELAYED_ASSERTION;
            AreadyControl == DENALI_CDN_AXI_READYCONTROL_DELAYED_ASSERTION;
            
			foreach(TransfersChannelDelay[i]){
                TransfersChannelDelay[i] inside {[min_intra_resp_delay:max_intra_resp_delay]};
			}

			//solve Type before min_delay, max_delay, min_ready_delay, max_ready_delay;
			solve num_transfers before min_delay, max_delay, min_ready_delay, max_ready_delay;
			solve min_delay before min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay;
			solve max_delay before min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay;		
			solve min_ready_delay before min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay;
			solve max_ready_delay before min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay;		
		 }

		 constraint delay_range_c {
			//For larger delay values, change distribution
			MaxDelayWriteAddressOffset inside {[min_ready_delay:max_ready_delay]};
			ChannelDelay inside {[min_delay:max_delay]};
			AddressDelay inside {[min_ready_delay:max_ready_delay]};
			TransmitDelay inside {[min_ready_delay:max_ready_delay]};
			BreadyDelay inside {[min_ready_delay:max_ready_delay]};
			solve delay_type_c before MaxDelayWriteAddressOffset,ChannelDelay, AddressDelay, TransmitDelay, BreadyDelay, TransfersChannelDelay, min_delay, max_delay, min_ready_delay, max_ready_delay;
		    solve min_delay before MaxDelayWriteAddressOffset,ChannelDelay, AddressDelay, TransmitDelay, BreadyDelay, TransfersChannelDelay;
		    solve max_delay before MaxDelayWriteAddressOffset,ChannelDelay, AddressDelay, TransmitDelay, BreadyDelay, TransfersChannelDelay;
		    solve min_ready_delay before MaxDelayWriteAddressOffset,ChannelDelay, AddressDelay, TransmitDelay, BreadyDelay, TransfersChannelDelay;
		    solve max_ready_delay before MaxDelayWriteAddressOffset,ChannelDelay, AddressDelay, TransmitDelay, BreadyDelay, TransfersChannelDelay;
		 }

         constraint forceId0_c {
            IdTag == 0;
         }

END_ADD
                if ($pkt_pLenW <13 && !$axi4p) {
                    my $maxBytes = (1<<$pkt_pLenW);
                $pre_addition     .= <<"END_ADD";
                 constraint maxPacketLength_c { // TEMP Constraint // To be reviewed
                     (Length * BurstSize) < $maxBytes; 
                 }
END_ADD
                }
                $in_usr_axi_tx = 0;
                if($axi4p && $rreorder) {
                $pre_addition     .= <<"END_ADD";
   // Constraint to restrict length for ROB 
   constraint len_temp_r {
     (Direction == DENALI_CDN_AXI_DIRECTION_READ) -> Length <= 8;
   }
END_ADD
                }
                if($axi4p && $wreorder) {
                $pre_addition     .= <<"END_ADD";
   // Constraint to restrict length for ROB 
   constraint len_temp_w {
     (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) -> Length <= 8;
                }
END_ADD
                }
                if ($inclDbgReg) {
                $pre_addition     .= <<"END_ADD";
   // Constraint to restrict length for ROB 
   constraint avoidDbgReg_c {
                     if (Type ==DENALI_CDN_AXI_TR_WriteAddress || Type ==DENALI_CDN_AXI_TR_WriteAddress) { !(StartAddress inside {[$dbgBaseAddr:$dbgEndAddr]});}
                }
END_ADD
                }
                $in_usr_axi_tx = 0;
            }
            if ($line =~ /endclass/ && $in_usr_ahb_tx) {
                $pre_addition = <<"END_ADD";
  // Constraint to not allow INCR of Undefined Length burst type 
  constraint usrKindIncrUndef_c { 
    Kind != DENALI_CDN_AHB_BURSTKIND_INCR;
  }
END_ADD
                if ($inclDbgReg) {
                $pre_addition     .= <<"END_ADD";
   // Constraint to restrict length for ROB 
   constraint avoidDbgReg_c {
                     if (Type == DENALI_CDN_AHB_TR_Transaction || Type == DENALI_CDN_AHB_TR_Transfer) { !(FirstAddress inside {[$dbgBaseAddr:$dbgEndAddr]});}
                }
END_ADD
		}
		$pre_addition     .= <<"END_ADD";
	        constraint delay_type_constr_c {
			if(custom_delay_type == 0 && custom_delay_range == 0) { 	
				delay_type_c dist {ZERO := 10, LOW:=30, MEDIUM:=30, HIGH:=30, CUSTOM :=0};
			}	
		 }
		 constraint delay_dist_c {
			if(custom_delay_range == 0) {
				if(delay_type_c == HIGH) {
					min_delay==101;
					max_delay==400;
				} else if(delay_type_c == MEDIUM){
					min_delay==21;
					max_delay==100;
				} else if(delay_type_c == LOW){
					min_delay==0;
					max_delay==20;
				}  else {
					min_delay==0;
					max_delay==0;
				}	
			}
		 }
		 constraint resp_delay_range_c {	
			num_transfers == Length;//Get number of transfer to randomize higher delay for any random transfer and lower for others
			if(custom_resp_delay_range == 0) { 	
				min_inter_resp_delay == min_delay;
				max_inter_resp_delay == max_delay;
				min_intra_resp_delay == (min_delay/num_transfers);
				//Avoid zero delays when num transfers are high
				if(max_delay<num_transfers){
					max_intra_resp_delay inside {[1:4]};
				} else {
					max_intra_resp_delay == (max_delay/num_transfers);
				}
			}
			
            foreach(TransfersSplitDelay[i]){
                TransfersSplitDelay[i] inside {[min_intra_resp_delay:max_intra_resp_delay]};
			}

			foreach(TransfersBusyDelay[i]){
                TransfersBusyDelay[i] inside {[min_intra_resp_delay:max_intra_resp_delay]};
			}

			foreach(TransfersResponsesDelay[i]){
                TransfersResponsesDelay[i] inside {[min_intra_resp_delay:max_intra_resp_delay]};
			}

			foreach(ArbiterTransfersResponseTerminationDelay[i]){
                ArbiterTransfersResponseTerminationDelay[i] inside {[min_intra_resp_delay:max_intra_resp_delay]};
			}

			solve num_transfers before min_delay, max_delay;
			solve min_delay before min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay;
			solve max_delay before min_inter_resp_delay, max_inter_resp_delay, min_intra_resp_delay, max_intra_resp_delay;
			//Below constraints get disabled when we disable default constraints on delays from VIP. So adding them back
			ArbiterTransfersResponseTerminationDelay.size() == Length;
			TransfersSplitDelay.size() == Length;
			TransfersResponsesDelay.size() == Length;
        	TransfersResponses.size() == Length;
			solve Length before ArbiterTransfersResponseTerminationDelay,TransfersSplitDelay,TransfersResponsesDelay,TransfersResponses, num_transfers;
								
		 }

		 constraint delay_range_c {
			TransmitDelay inside {[min_delay:max_delay]};
			RetryDelay inside {[min_delay:max_delay]};
			DeassertRequestDelay inside {[min_delay:max_delay]};
			LastBusyDelay inside {[min_delay:max_delay]};
			SplitDelay inside {[min_delay:max_delay]};
			BurstDelay dist {[min_delay:(min_delay+((max_delay-min_delay)/4))] :=40, [(min_delay+((max_delay-min_delay)/4)):(min_delay+((max_delay-min_delay)/2))] :=30, [(min_delay+((max_delay-min_delay)/2)):(min_delay+(3*(max_delay-min_delay)/4))] :=20, [(min_delay+(3*(max_delay-min_delay)/4)):max_delay]:=10};
			solve delay_type_c before TransmitDelay, RetryDelay, DeassertRequestDelay, LastBusyDelay, SplitDelay, BurstDelay, TransfersSplitDelay, TransfersBusyDelay, TransfersResponsesDelay, ArbiterTransfersResponseTerminationDelay, min_delay, max_delay;
		    solve min_delay before TransmitDelay, RetryDelay, DeassertRequestDelay, LastBusyDelay, SplitDelay, BurstDelay, TransfersSplitDelay, TransfersBusyDelay, TransfersResponsesDelay, ArbiterTransfersResponseTerminationDelay;
		    solve max_delay before TransmitDelay, RetryDelay, DeassertRequestDelay, LastBusyDelay, SplitDelay, BurstDelay, TransfersSplitDelay, TransfersBusyDelay, TransfersResponsesDelay, ArbiterTransfersResponseTerminationDelay;
		 }
END_ADD
                $in_usr_ahb_tx = 0;
            }

            if ($line =~ /endclass/ && $in_usr_apb_tx) {
                if ($inclDbgReg) {
                $pre_addition     .= <<"END_ADD";
            constraint avoidDbgReg_c {
                if (Type == DENALI_CDN_APB_TR_Transfer) { !(Addr inside {[$dbgBaseAddr:$dbgEndAddr]});}
            }

END_ADD
                }

                if ($pkt_Version>1) {
                    $pre_addition     .= <<"END_ADD";

        constraint address_unaligned_const {
  	        Addr[1:0] dist { 
                2'b00 := 75, 
                2'b01 := 10,
                2'b10 := 5,
                2'b11 := 10
            };
        }

END_ADD
                }

		$pre_addition     .= <<"END_ADD";
		 constraint delay_type_constr_c {
			if(custom_delay_type == 0 && custom_delay_range == 0) { 	
				delay_type_c dist {ZERO := 10, LOW:=30, MEDIUM:=30, HIGH:=30, CUSTOM :=0};
			}	
		 }

		 constraint delay_dist_c {
			if(custom_delay_range == 0) {
				if(delay_type_c == HIGH) {
					min_delay==51;
					max_delay==100;
				} else if(delay_type_c == MEDIUM){
					min_delay==11;
					max_delay==50;
				} else if(delay_type_c == LOW){
					min_delay==0;
					max_delay==10;
				}  else {
					min_delay==0;
					max_delay==0;
				}	
			}
		 }

		 constraint delay_range_c {
			ReqResponseDelay inside {[min_delay:max_delay]};
			solve delay_type_c before  ReqResponseDelay, min_delay, max_delay;
		    solve min_delay before  ReqResponseDelay;
		    solve max_delay before  ReqResponseDelay;
		 }

END_ADD

                $in_usr_apb_tx = 0;
            }
        
        
            if ($line =~ /axi_agent.regInst.writeReg\(DENALI_CDN_AXI_REG_DoSignalCheckOnlyWhenValid, 1\);/) {
                $set_master_callback = 1;
            }
            if ($line =~ /end/ && $set_master_callback) {
                $pre_addition       = "\t//axi_agent.regInst.writeReg(DENALI_CDN_AXI_REG_UseSparseStrobes, 1);\n";
                $set_master_callback = 0;
            }
            if ($line =~ /function void configure_axi_slave\(cdnAxiUvmAgent slave_agent\)/) {
                $set_slave_callback = 1;
            }
            if ($line =~ /endfunction/ && $set_slave_callback) {
                $pre_addition       = "\t\tvoid'(slave_agent.inst.setCallback(DENALI_CDN_AXI_CB_BeforeSendResponse));\n";
                $set_slave_callback = 0;
            }
            if ($line =~ /function void configure_axi_master_mon\(cdnAxiUvmAgent master_agent\)/) {
                $set_UpdateErrorcontrol = 1;
            }
            if ($line =~ /end/ && $set_UpdateErrorcontrol) {
                $pre_addition = "\t\taxi_UpdateErrorcontrol(master_agent,CDN_AXI_FATAL_ERR_VR_AXI3175_SENT_WRITE_DEVICE_TRANSACTION_TO_NON_SYSTEM_DOMAIN,DENALI_CDN_AXI_ERR_CONFIG_SEVERITY_Silent);\n";
                $pre_addition1 = "\t\taxi_UpdateErrorcontrol(master_agent,CDN_AXI_FATAL_ERR_VR_AXI3174_SENT_READ_DEVICE_TRANSACTION_TO_NON_SYSTEM_DOMAIN,DENALI_CDN_AXI_ERR_CONFIG_SEVERITY_Silent);\n";
                $pre_addition2 = "\t\taxi_UpdateErrorcontrol(master_agent,CDN_AXI_FATAL_ERR_VR_AXI3169_WRONG_SIZE_FOR_SHAREABLE_WRITE,DENALI_CDN_AXI_ERR_CONFIG_SEVERITY_Silent);\n";
                $pre_addition2 .= "\t\t\t\t\taxi_UpdateErrorcontrol(master_agent,CDN_AXI_FATAL_ERR_VR_AXI145_EXCLUSIVE_WRITE_WITH_NO_EXCLUSIVE_READ, DENALI_CDN_AXI_ERR_CONFIG_SEVERITY_Silent);\n";
                $post_addition = "\t\taxi_UpdateErrorcontrol(master_agent,CDN_AXI_FATAL_ERR_VR_AXI3168_WRONG_SIZE_FOR_SHAREABLE_READ,DENALI_CDN_AXI_ERR_CONFIG_SEVERITY_Silent);\n";
                $set_UpdateErrorcontrol = 0;
           }

            if ($line =~ /function void configure_apb_slave_mon\(cdnApbUvmAgent agent\)/) {
                $set_mon_timeout_callback = 1;
            }
            if ($line =~ /end/ && $set_mon_timeout_callback) {
                $pre_addition             = "\t\t\t\tapb_UpdateErrorcontrol(agent,CDN_APB_NONFATAL_ERR_CDN_APB023_ADDR_NOT_ALIGNED,DENALI_CDN_APB_ERR_CONFIG_SEVERITY_Silent);\n\t\t\t\tagent.regInst.writeReg(DENALI_CDN_APB_REG_TransferTimeout,'h1000000);\n";
                $set_mon_timeout_callback = 0;
            }
            if ($line =~ /function void configure_apb_master_mon\(cdnApbUvmAgent agent\)/) {
                $set_mon_timeout_callback = 1;
            }
            if ($line =~ /end/ && $set_mon_timeout_callback) {
                $pre_addition             = "\t\t\t\tapb_UpdateErrorcontrol(agent,CDN_APB_NONFATAL_ERR_CDN_APB023_ADDR_NOT_ALIGNED,DENALI_CDN_APB_ERR_CONFIG_SEVERITY_Silent);\n\t\t\t\tagent.regInst.writeReg(DENALI_CDN_APB_REG_TransferTimeout,'h1000000);\n";
                $set_mon_timeout_callback = 0;
            }
            if ($line =~ /function void configure_ahb_slave_mon\(cdnAhbUvmAgent agent\)/) {
                $set_UpdateErrorcontrol_ahb_a = 1;
            }
            if ($line =~ /end/ && $set_UpdateErrorcontrol_ahb_a) {
                $pre_addition = "\t\t\t\tahb_UpdateErrorcontrol(agent,CDN_AHB_FATAL_ERR_VR_AHB242_NO_HREADY_HIGH_DURING_RESET,DENALI_CDN_AHB_ERR_CONFIG_SEVERITY_Silent);\n";
                $pre_addition1 ="\t\t\t\tahb_UpdateErrorcontrol(agent,CDN_AHB_FATAL_SLAVE_NO_ZERO_DELAY_OK_AND_HREADY_HIGH,DENALI_CDN_AHB_ERR_CONFIG_SEVERITY_Silent);\n";
                $pre_addition1 .= "\t\t\t\tif(!\$test\$plusargs(\"incr_undef_enabled\")) begin\n\t\t\t\t\tahb_UpdateErrorcontrol(agent,CDN_AHB_FATAL_ERR_VR_AHB230_SLAVE_BUS_LOCK,DENALI_CDN_AHB_ERR_CONFIG_SEVERITY_Silent);\n\t\t\t\tend\n";
                $set_UpdateErrorcontrol_ahb_a = 0;
            }
            if ($line =~ /function void configure_ahb_master_mon\(cdnAhbUvmAgent agent\)/) {
                $set_UpdateErrorcontrol_ahb_b = 1;
            }
            if ($line =~ /end/ && $set_UpdateErrorcontrol_ahb_b) {
                $pre_addition = "\t\t\t\tahb_UpdateErrorcontrol(agent,CDN_AHB_FATAL_ERR_VR_AHB242_NO_HREADY_HIGH_DURING_RESET,DENALI_CDN_AHB_ERR_CONFIG_SEVERITY_Silent);\n";
                $pre_addition .= "\t\t\t\tif(!\$test\$plusargs(\"incr_undef_enabled\")) begin\n\t\t\t\t\tahb_UpdateErrorcontrol(agent,CDN_AHB_FATAL_ERR_VR_AHB230_SLAVE_BUS_LOCK,DENALI_CDN_AHB_ERR_CONFIG_SEVERITY_Silent);\n\t\t\t\tend\t";
                # $pre_addition = "\t\tahb_UpdateErrorcontrol(agent,CDN_AHB_FATAL_ERR_VR_AHB120_MSTR_BAD_ADDR_INCREMENT,DENALI_CDN_AHB_ERR_CONFIG_SEVERITY_Silent);\n";
                $set_UpdateErrorcontrol_ahb_b = 0;
            }

            if ($line =~ /constraint usrAce_c / && $AceLitePresent) {
               #ACELite protocol is supported for any Initaitor Below constraint are added for Barrier Transaction
               $pre_addition     = <<"END_ADD";
               constraint usrAce_barrier_c {
                 if (SpecSubtype == DENALI_CDN_AXI_SPECSUBTYPE_ACE) {
                    IsBarrier == DENALI_CDN_AXI_ISBARRIER_BARRIER ;
                    Barrier == DENALI_CDN_AXI_BARRIER_MEMORY_BARRIER;
                    Cacheable == DENALI_CDN_AXI_CACHEMODE_CACHEABLE;
                    Bufferable == DENALI_CDN_AXI_BUFFERMODE_NON_BUFFERABLE;
                    ReadAllocate == DENALI_CDN_AXI_READALLOCATE_NO_READ_ALLOCATE;
                    WriteAllocate == DENALI_CDN_AXI_WRITEALLOCATE_NO_WRITE_ALLOCATE;
                    Kind == DENALI_CDN_AXI_BURSTKIND_INCR;
                    Size == BurstMaxSize;
                    Length == 1;
                    StartAddress == 'h0;
                    Privileged == 'h1;
                    Secure == 'h1;
                    DataInstr == 'h1;
                    Domain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE; // all address spaces are NON_SHAREABLE by default
                    IsDvm == DENALI_CDN_AXI_DVM_NOT_DVM;
                    if (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) WriteSnoop == DENALI_CDN_AXI_WRITESNOOP_WriteUnique;
                    if (Direction == DENALI_CDN_AXI_DIRECTION_READ) ReadSnoop == DENALI_CDN_AXI_READSNOOP_ReadOnce;
                 }
                 }
                 constraint usrAce_ReadSnoop {
                 if (SpecSubtype == DENALI_CDN_AXI_SPECSUBTYPE_ACE) {
                    IsBarrier == DENALI_CDN_AXI_ISBARRIER_NOT_BARRIER;
                    Cacheable == DENALI_CDN_AXI_CACHEMODE_CACHEABLE;
                    Bufferable == DENALI_CDN_AXI_BUFFERMODE_NON_BUFFERABLE;
                    //Kind == DENALI_CDN_AXI_BURSTKIND_INCR;
                    //Size == BurstMaxSize;
                    //Length == 1;
                    //StartAddress == 'h0;
               
                    Domain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE; // all address spaces are NON_SHAREABLE by default
                    IsDvm == DENALI_CDN_AXI_DVM_NOT_DVM;
                    //if (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) WriteSnoop == DENALI_CDN_AXI_WRITESNOOP_WriteUnique;
                    //if (Direction == DENALI_CDN_AXI_DIRECTION_READ) ReadSnoop == DENALI_CDN_AXI_READSNOOP_CleanInvalid;
                 }
                 }
                 constraint usrAce_WriteSnoop {
                 if (SpecSubtype == DENALI_CDN_AXI_SPECSUBTYPE_ACE) {
                    IsBarrier == DENALI_CDN_AXI_ISBARRIER_NOT_BARRIER;
                    Cacheable == DENALI_CDN_AXI_CACHEMODE_CACHEABLE;
                    Bufferable == DENALI_CDN_AXI_BUFFERMODE_NON_BUFFERABLE;
                    if (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) WriteSnoop == DENALI_CDN_AXI_WRITESNOOP_WriteLineUnique;
                    if (Direction == DENALI_CDN_AXI_DIRECTION_READ) ReadSnoop == DENALI_CDN_AXI_READSNOOP_ReadOnce;
                    Domain == DENALI_CDN_AXI_DOMAIN_INNER;
                    IsDvm == DENALI_CDN_AXI_DVM_NOT_DVM;
                 }
                 }
                 constraint usrAce_caheable {
                    Cacheable == DENALI_CDN_AXI_CACHEMODE_CACHEABLE;
                    Bufferable == DENALI_CDN_AXI_BUFFERMODE_NON_BUFFERABLE;
                 } 
                 constraint usrAce_Global {
                  if(SpecSubtype == DENALI_CDN_AXI_SPECSUBTYPE_ACE) {
                    Barrier == DENALI_CDN_AXI_BARRIER_NORMAL_RESPECTING;
                    if (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) WriteSnoop inside {DENALI_CDN_AXI_WRITESNOOP_WriteLineUnique, DENALI_CDN_AXI_WRITESNOOP_WriteUnique, DENALI_CDN_AXI_WRITESNOOP_UNSET};
                    if (Direction == DENALI_CDN_AXI_DIRECTION_READ) ReadSnoop inside {DENALI_CDN_AXI_READSNOOP_ReadOnce, DENALI_CDN_AXI_READSNOOP_CleanShared, DENALI_CDN_AXI_READSNOOP_CleanInvalid, DENALI_CDN_AXI_READSNOOP_MakeInvalid, DENALI_CDN_AXI_READSNOOP_UNSET};
                  }
                }
END_ADD
             } 

            print OUTFILE "$pre_addition";
            print OUTFILE "$pre_addition1";
            print OUTFILE "$pre_addition2";

            #Check if there is any ACELite Initiator is present
            my $aceIEACnt = 0;
            foreach my $iea (keys %ieaInfo) {
              my $ieaBus   = $ieaInfo{$iea}->{bus};
              if($ieaBus eq "ACELite"){
                $aceIEACnt++;
              } elsif($ieaBus eq "AHB") {
                my $ace = $ieaInfo{$iea}->{ace};
                if($ace) {
                  $aceIEACnt++;
                }
              }
            }
            #If ACE IEA are present, check for TEA
            my @aceTargets;
            if($aceIEACnt){
              foreach my $tea (keys %teaInfo) {
                my $teaBus   = $teaInfo{$tea}->{bus};
                if($teaBus eq "ACELite"){
                  my $bus = "AXIACE";
                  push(@aceTargets, {tgt=>${tea}, bus=>${bus}});  
                } elsif($teaBus eq "AHB") {
                  my $ace = $teaInfo{$tea}->{ace};
                  if($ace) {
                    my $bus = "AHBACE";
                    push(@aceTargets, {tgt=>${tea}, bus=>${bus}});  
                  }
                }
              }
            }            

            if (   ($line =~ /class cdn_axi_master_single_trans_seq_user extends cdn_axi_master_single_trans_seq;/)
                || (($line =~ /\/\/ Factory overrides registration/) && ($add_axiiea_constraints))) {
                $in_usr_axi_dwn_sizing = 1;
                print OUTFILE "class cdn_axi_master_single_trans_seq_user extends cdn_axi_master_single_trans_seq; \n";
                print OUTFILE "   `uvm_object_utils(cdn_axi_master_single_trans_seq_user) \n";
                print OUTFILE "   bit disable_constraints = 1'b0; \n";
                print OUTFILE "   bit allow_illegals = 1'b0; \n";
                print OUTFILE "   bit add_for_ace = 1'b0; \n";
                print OUTFILE "   cdn_stg_addr_t non_shareable_base[\$], inner_shareable_base[\$], outer_shareable_base[\$], system_shareable_base[\$];\n";
                print OUTFILE "   cdn_stg_addr_t non_shareable_end[\$], inner_shareable_end[\$], outer_shareable_end[\$], system_shareable_end[\$];\n";
                print OUTFILE "   string domain_type;\n";
                print OUTFILE "   int index = 0;\n\n";
                print OUTFILE "   function new(string name = \"cdn_axi_master_single_trans_seq_user\"); \n";
                print OUTFILE "      string testname; \n";
                print OUTFILE "      super.new(name); \n";
                print OUTFILE "      if(\$value\$plusargs(\"UVM_TESTNAME=%s\", testname)) begin\n";
                print OUTFILE "         if (testname == \"min_latency_test\" || testname == \"max_bandwidth_test\" || testname == \"ot_sweep_test\") begin \n";
                print OUTFILE "             disable_constraints = 1'b1; \n";
                print OUTFILE "         end else if (testname == \"all_masters_random_segments_test\" || testname == \"single_master_random_segments_test\" || testname == \"all_masters_unmapped_segments_test\" || testname == \"single_master_unmapped_segments_test\") begin \n";
                print OUTFILE "             add_for_ace = 1'b1; \n";
                print OUTFILE "         end; \n";
                print OUTFILE "      end; \n";
                print OUTFILE "      if(\$test\$plusargs(\"allow_illegals\")) begin\n";
                print OUTFILE "         allow_illegals = 1'b1; \n";
                print OUTFILE "      end; \n";
                print OUTFILE "   endfunction : new \n";

                print OUTFILE "   virtual task do_item(); \n";
                print OUTFILE "   \tbit rand_illegal = (\$urandom_range(1, 10) < 3); \n";
                print OUTFILE "   \t`uvm_create(burst) \n";

                print OUTFILE "   \tif (disable_constraints || allow_illegals && rand_illegal) begin \n";
                print OUTFILE "   \t\tif (disable_constraints) begin\n";
                print OUTFILE "   \t\t\tsuper.do_item(); // default behaviour for all other cases \n";
                print OUTFILE "   \t\tend\n";
                foreach my $iea (keys %axi4IeaInfo) {
                    my $rReorder = $axi4IeaInfo{$iea}->{rReorder} eq 'qm' ? 1 : 0;
                    my $maxRDP = $axi4IeaInfo{$iea}->{maxRDP} // 0;
                    if ($rReorder) {
                        print OUTFILE "   \t\telse if (in_port_name == \"$iea\") begin \n";
                        print OUTFILE "   \t\t\tvoid'(burst.randomize() with { \n";
                        print OUTFILE "   \t\t\t\tif(Direction == DENALI_CDN_AXI_DIRECTION_READ) Length <= $maxRDP;  \n";
                        print OUTFILE "   \t\t\t\tStartAddress inside {[start_address:end_address]};  \n";
                        print OUTFILE "   \t\t\t\tStartAddress + (Length*BurstSize) <= end_address;  \n";
                        print OUTFILE "   \t\t\t\tif (Direction == DENALI_CDN_AXI_DIRECTION_READ)  {IdTag <= maxReadIdTag};  \n";
                        print OUTFILE "   \t\t\t\tif (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) {IdTag <= maxWriteIdTag};  \n";
                        print OUTFILE "   \t\t\t\tBurstMaxSize == maxSize;  \n";
                        print OUTFILE "   \t\t\t}); \n";
                        print OUTFILE "   \t\t\t`uvm_send(burst) \n";
                        print OUTFILE "   \t\tend\n";
                    }
                }
                print OUTFILE "   \t\telse begin\n";
                print OUTFILE "   \t\t\tsuper.do_item(); // default behaviour for all other cases \n";
                print OUTFILE "   \t\tend\n";

                foreach my $iea (keys %axi4IeaInfo) {
                    my $rReorder = $axi4IeaInfo{$iea}->{rReorder} eq 'qm' ? 1 : 0;
                    my $wReorder = $axi4IeaInfo{$iea}->{wReorder} eq 'qm' ? 1 : 0;
                    my $maxRDP = $axi4IeaInfo{$iea}->{maxRDP} // 0;
                    my $ieaBus   = $axi4IeaInfo{$iea}->{bus};
                    if (grep {$_ eq "*ID0"} @{ $axi4IeaInfo{$iea}->{targets}} ) {
                        print OUTFILE "   \tend else if (in_port_name == \"$iea\" && start_address == $dbgBaseAddr) begin \n";
                        print OUTFILE "   \t\tvoid'(burst.randomize() with { \n";
                        print OUTFILE "\t\t\t\tBurstSize == 4;\n";
                        print OUTFILE "\t\t\t\tLength == 1;\n";
                        print OUTFILE "\t\t\t\tStartAddress[1:0] == 2'b0;  \n";
                        print OUTFILE "\t\t\t\tStartAddress inside {[start_address:end_address]};  \n";
                        print OUTFILE "\t\t\t\tStartAddress + (Length*BurstSize) <= end_address;  \n";
                        print OUTFILE "\t\t\t}); \n";
                        print OUTFILE "  \t`uvm_send(burst) \n";
                    }
                    foreach my $tea (@{ $axi4IeaInfo{$iea}->{targets} }) {
                        next if ($tea eq "*ID0");
                        my $ieaSize = $axi4IeaInfo{$iea}->{dataW} / 8;
                        #Targets need not be AXI so use general teaInfo for target parameters
                        my $teaSize  = $teaInfo{$tea}->{dataW} / 8;
                        my $teaAddrW = $teaInfo{$tea}->{addrW};
                        my $teaBus   = $teaInfo{$tea}->{bus};
                        if (   ($teaBus eq "AXI4" || $teaBus eq "ACELite")
                            || ($teaAddrW < 12)
                            || ($teaBus eq "APB")
                            || ($teaBus eq "AHB")
                            || ($rReorder || $wReorder)) {
                            my $max_wrap_length = int(16 * $teaSize / $ieaSize);
                            my $max_incr_length = int(256 * $teaSize / $ieaSize);
                            print OUTFILE "   \tend else if (in_port_name == \"$iea\" && out_port_name == \"$tea\") begin \n";

                            print OUTFILE "     \t\tnon_shareable_base = {};\n";
                            print OUTFILE "     \t\tinner_shareable_base = {};\n";
                            print OUTFILE "     \t\touter_shareable_base = {};\n";
                            print OUTFILE "     \t\tsystem_shareable_base = {};\n\n";
                            print OUTFILE "     \t\tnon_shareable_end = {};\n";
                            print OUTFILE "     \t\tinner_shareable_end = {};\n";
                            print OUTFILE "     \t\touter_shareable_end = {};\n";
                            print OUTFILE "     \t\tsystem_shareable_end = {};\n\n";

                            foreach my $amapEntry (@{$axi4IeaInfo{$iea}->{aMap}}) {
                              my $tea = $amapEntry->{tgt};
                              next if ($tea eq "*ID0");
                              my $base = sprintf("0x%X", $amapEntry->{baseAddr});
                              my $addr = '64\'h'.sprintf("%x", hex($base));
                              my $mask = hex(sprintf("0x%X", $amapEntry->{mask}));
                              my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                              if ($base==0 && $mask==0) {
                                $range = sprintf("0x%x", (1<<(int($axi4IeaInfo{$iea}->{addrW}))));
                              }
                              
                              if($aceIEACnt) {
                                my $tgtFound = 0;
                                foreach my $tgt (@aceTargets){
                                  if($tgt->{tgt} eq $tea){
                                    $tgtFound = 1;
                                    my $bus = $tgt->{bus};
                                    my $minRange;
                                    my $eachRegionRange;
                                    my $regionAddr;
                                    if($bus eq "AHBACE") {
                                      $minRange = "0x1000";         #For AHB Slave Min Region is considered 1K, so check for 4K
                                      $eachRegionRange = "0x400";
                                    } elsif ($bus eq "AXIACE") {
                                      $minRange = "0x4000";         #For AXI Slave Min Region is considered 4K, so check for 16K
                                      $eachRegionRange = "0x1000";
                                    }

                                    # Support for Interleaved Configurations
                                    my $rangeMask = (1 << (int($axi4IeaInfo{$iea}->{addrW}))) - 1;
                                    my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                    my $interleavedBase = hex($base);
                                    my $pushCnt = 0;
                                    my $interleaved = 0;
                                    while (($interleavedBase < $maxInterleavedAddr)){
                                      if(($interleavedBase & $mask) == hex($base)){
                                        if($interleavedBase != hex($base)){
                                          $interleaved++;
                                          last;
                                        }
                                      }
                                      $interleavedBase = $interleavedBase + hex($range);
                                    }
                                    my $interleavedEntries = $interleaved ? int((($maxInterleavedAddr + 1) - hex($base)) / ($interleavedBase - hex($base))) : 0;
                                    if($interleavedEntries > 0 && $interleavedEntries <= 16) {   # All Entries would be part of Routing Table
                                      $interleavedBase = hex($base);
                                      my $pushCnt = 0;
                                      while ($interleavedBase < $maxInterleavedAddr){
                                        if(($interleavedBase & $mask) == hex($base)){
                                          $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                          $regionEndAddr = '64\'h'.sprintf("%x", $interleavedBase+hex($range));
                                          if(int($pushCnt%4) == 0) {
                                            print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tnon_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif(int($pushCnt%4) == 1) {
                                            print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tinner_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif(int($pushCnt%4) == 2) {
                                            print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\touter_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif(int($pushCnt%4) == 3) {
                                            print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tsystem_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          $pushCnt++;
                                        }
                                        $interleavedBase = $interleavedBase + hex($range);
                                      } 
                                    }
                                    elsif($interleavedEntries > 16){
                                      $interleavedBase = hex($base);
                                      while ($interleavedBase < $maxInterleavedAddr){
                                        if(($interleavedBase & $mask) == hex($base)){
                                          $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                          $regionEndAddr = '64\'h'.sprintf("%x", $interleavedBase+hex($range));
                                          if($interleavedBase < ($maxInterleavedAddr+1)/4) {
                                            print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tnon_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif($interleavedBase >= ($maxInterleavedAddr+1)/4 && $interleavedBase < ($maxInterleavedAddr+1)/2) {
                                            print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tinner_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif($interleavedBase >= ($maxInterleavedAddr+1)/2 && $interleavedBase < ($maxInterleavedAddr+1)*3/4) {
                                            print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\touter_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif($interleavedBase >= ($maxInterleavedAddr+1)*3/4 && $interleavedBase < ($maxInterleavedAddr+1)) {
                                            print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tsystem_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                        }
                                        $interleavedBase = $interleavedBase + hex($range);
                                      }
                                    }
                                    else {
                                      if(hex($range) >= hex($minRange)){    
                                        #Divide into Equal 4 Regions
                                        print OUTFILE "     \t\tnon_shareable_base.push_back(${addr});\n";
                                        print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4).");\n";

                                        $regionAddr = hex($base) + hex($range)/4;
                                        $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                        print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tinner_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4).");\n";

                                        $regionAddr = hex($base) + hex($range)/4 + hex($range)/4;
                                        $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                        print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\touter_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4).");\n";

                                        $regionAddr = hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4;
                                        $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                        print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tsystem_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4 + hex($range)/4).");\n";
                                      } elsif (hex($range) < hex($minRange)){
                                        
                                        $regionRange = hex($eachRegionRange);
                                        $regionRange = '0x'.sprintf("%x", $regionRange);
                                        print OUTFILE "     \t\tnon_shareable_base.push_back(${addr});\n";
                                        print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange)).");\n";

                                        if((hex($range) - hex($eachRegionRange)) >=  hex($eachRegionRange)) {
                                          $regionAddr = hex($base) + hex($eachRegionRange);
                                          $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                          print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                          print OUTFILE "     \t\tinner_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange) + hex($eachRegionRange)).");\n";
                                        }

                                        if((hex($range) - 2*hex($eachRegionRange)) >=  hex($eachRegionRange)) {
                                          $regionAddr = hex($base) + hex($eachRegionRange) + hex($eachRegionRange);
                                          $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                          print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                          print OUTFILE "     \t\touter_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange) + hex($eachRegionRange) + hex($eachRegionRange)).");\n";
                                        }
                                      }
                                    }
                                  }
                                }
                                if($tgtFound == 0){
                                  # Supportfor Interleaved Configurations
                                  my $rangeMask = (1 << (int($axi4IeaInfo{$iea}->{addrW}))) - 1;
                                  my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                  my $interleavedBase = hex($base);
                                  while ($interleavedBase < $maxInterleavedAddr){
                                    if(($interleavedBase & $mask) == hex($base)){
                                      $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                      print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                      print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", $interleavedBase + hex($range)).");\n";
                                    }
                                    $interleavedBase = $interleavedBase + hex($range);
                                  } 
                                }
                              } else {
                                my $rangeMask = (1 << (int($axi4IeaInfo{$iea}->{addrW}))) - 1;
                                my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                my $interleavedBase = hex($base);
                                while ($interleavedBase < $maxInterleavedAddr){
                                  if(($interleavedBase & $mask) == hex($base)){
                                    $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                    print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                    print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", $interleavedBase + hex($range)).");\n";
                                  }
                                  $interleavedBase = $interleavedBase + hex($range);
                                }
                              }
                            }
                       
                            print OUTFILE "\n     \t\tforeach (non_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\tif(non_shareable_base[i] <= start_address && non_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\tdomain_type = \"NON_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            print OUTFILE "     \t\tif(index == 0) begin\n";
                            print OUTFILE "     \t\t\tforeach (inner_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\t\tif(inner_shareable_base[i] <= start_address && inner_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\t\tdomain_type = \"INNER_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\t\tend\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            print OUTFILE "     \t\tif(index == 0) begin\n";
                            print OUTFILE "     \t\t\tforeach (outer_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\t\tif(outer_shareable_base[i] <= start_address && outer_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\t\tdomain_type = \"OUTER_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\t\tend\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            print OUTFILE "     \t\tif(index == 0) begin\n";
                            print OUTFILE "     \t\t\tforeach (system_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\t\tif(system_shareable_base[i] <= start_address && system_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\t\tdomain_type = \"SYSTEM_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\t\tend\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";

                            my $ismapped = 1;
                            if($ieaBus ne "ACELite" || ($ieaSize < $teaSize)){
                               $ismapped = 0;
                            }

                            print OUTFILE "   \t\tvoid'(burst.randomize() with { \n";
                            if ($teaBus eq "APB") {
                                print OUTFILE
                                  "\t\t\t\tif (Direction == DENALI_CDN_AXI_DIRECTION_READ)  {IdTag <= maxReadIdTag};  \n";
                                print OUTFILE
                                  "\t\t\t\tif (Direction == DENALI_CDN_AXI_DIRECTION_WRITE) {IdTag <= maxWriteIdTag};  \n";
                                print OUTFILE "\t\t\t\tCacheable == DENALI_CDN_AXI_CACHEMODE_CACHEABLE;  \n";
                                print OUTFILE "\t\t\t\tBufferable == DENALI_CDN_AXI_BUFFERMODE_NON_BUFFERABLE;  \n";
                                if (($ieaSize > $teaSize)) {
                                    print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_FIXED) BurstSize <= $teaSize;\n";
                                    print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_WRAP) Length*BurstSize <= 16*$teaSize;\n";
                                    print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_INCR) Length*BurstSize <= 256*$teaSize;\n";
                                }
                                #Support for ACELite
                                if($ieaBus eq "ACELite"){
                                  print OUTFILE "\t\t\t\tDomain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE;\n"; 
                                  print OUTFILE "\t\t\t\tBarrier == DENALI_CDN_AXI_BARRIER_NORMAL_RESPECTING;\n";
                                  print OUTFILE "\t\t\t\tType inside { DENALI_CDN_AXI_TR_Write, DENALI_CDN_AXI_TR_Read};\n";
                                }
                            }
                            if ($teaBus eq "AHB") {
                                print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_FIXED) BurstSize <= $teaSize;\n";  
                                print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_WRAP) Length*BurstSize <= 16*$teaSize;\n";
                                print OUTFILE 
                                  "\t\t\t\t(StartAddress % (1 << BurstSize)) == 0;\n";
                                print OUTFILE 
                                  "\t\t\t\tLength*BurstSize <= 1024;\n";
                                print OUTFILE 
                                  "\t\t\t\t(StartAddress % 1024) + Length*BurstSize <= 1024;\n";

                                #Support for ACELite
                                if($ieaBus eq "ACELite"){
                                  my $ace = $teaInfo{$tea}->{ace};
                                  if($ace == 0){
                                    print OUTFILE "\t\t\t\tDomain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE;\n"; 
                                  } else {
                                    print OUTFILE "\t\t\t\t\tif(domain_type == \"NON_SHAREABLE\") Domain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE;\n"; 
                                    print OUTFILE "\t\t\t\t\telse if(domain_type == \"INNER_SHAREABLE\") Domain == DENALI_CDN_AXI_DOMAIN_INNER;\n"; 
                                    print OUTFILE "\t\t\t\t\telse if(domain_type == \"OUTER_SHAREABLE\") Domain == DENALI_CDN_AXI_DOMAIN_OUTER;\n"; 
                                    print OUTFILE "\t\t\t\t\telse Domain == DENALI_CDN_AXI_DOMAIN_SYSTEM;\n"; 
                                  }
                                  print OUTFILE "\t\t\t\tBarrier == DENALI_CDN_AXI_BARRIER_NORMAL_RESPECTING;\n";
                                  print OUTFILE "\t\t\t\tType inside { DENALI_CDN_AXI_TR_Write, DENALI_CDN_AXI_TR_Read};\n";
                                }
                            }
                            if (($ieaSize > $teaSize) && ($teaBus eq "AXI4" || $teaBus eq "ACELite")) {
                                print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_FIXED) BurstSize <=$teaSize;  \n";
                                print OUTFILE "\t\t\t\tif(Access == DENALI_CDN_AXI_ACCESS_EXCLUSIVE) BurstSize <=$teaSize;  \n";
                                print OUTFILE
                                  "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_WRAP) Length*BurstSize <=16*$teaSize;  \n";
                                print OUTFILE
                                  "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_FIXED) Length*BurstSize <=16*$teaSize;  \n";
                                print OUTFILE
                                  "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_INCR) Length*BurstSize <=256*$teaSize;  \n";
                            }
                            if(($teaBus eq "AXI4" || $teaBus eq "ACELite")){
                              #Support for ACELite
                              if($ieaBus eq "ACELite"){
                                if($teaBus ne "ACELite") {
                                  print OUTFILE "\t\t\t\tDomain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE;\n"; 
                                  print OUTFILE "\t\t\t\tBarrier == DENALI_CDN_AXI_BARRIER_NORMAL_RESPECTING;\n";
                                  print OUTFILE "\t\t\t\tType inside { DENALI_CDN_AXI_TR_Write, DENALI_CDN_AXI_TR_Read};\n";
                                } else {
                                  print OUTFILE "\t\t\t\tif(domain_type == \"NON_SHAREABLE\") Domain == DENALI_CDN_AXI_DOMAIN_NON_SHAREABLE;\n"; 
                                  print OUTFILE "\t\t\t\telse if(domain_type == \"INNER_SHAREABLE\") Domain == DENALI_CDN_AXI_DOMAIN_INNER;\n"; 
                                  print OUTFILE "\t\t\t\telse if(domain_type == \"OUTER_SHAREABLE\") Domain == DENALI_CDN_AXI_DOMAIN_OUTER;\n"; 
                                  print OUTFILE "\t\t\t\telse Domain == DENALI_CDN_AXI_DOMAIN_SYSTEM;\n"; 
                                }
                              }
                            }
                            if ($teaAddrW < 12) {
                                print OUTFILE "\t\t\t\tif(Kind == DENALI_CDN_AXI_BURSTKIND_INCR) (StartAddress>>$teaAddrW) == (StartAddress+Length*BurstSize>>$teaAddrW);  \n";
                            }
                            if($rReorder){
                              print OUTFILE "\t\t\t\tif(Direction == DENALI_CDN_AXI_DIRECTION_READ) Length <= $maxRDP;  \n";
                            }
                            if(!$ismapped) {

                              my $mappedRegionStr = "";
                              foreach my $amapInfo (@{$axi4IeaInfo{$iea}->{aMap}}) {
                                my $base = sprintf("0x%X", $amapInfo->{baseAddr});
                                my $mask = hex(sprintf("0x%X", $amapInfo->{mask}));
                                my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                                if ($base==0 && $mask==0) {
                                  $range = sprintf("0x%x", (1<<(int($axi4IeaInfo{$iea}->{addrW}))));
                                }
                                my $rangeMask = (1 << (int($axi4IeaInfo{$iea}->{addrW}))) - 1;
                                my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                my $interleavedBase = hex($base);
                                my $interleaved = 0;
                                while (($interleavedBase < $maxInterleavedAddr)){
                                  if(($interleavedBase & $mask) == hex($base)){
                                    if($interleavedBase != hex($base)){
                                      $interleaved++;
                                      last;
                                    }
                                  }
                                  $interleavedBase = $interleavedBase + hex($range);
                                }                              
                                $tgtStartAddr = '64\'h'.sprintf("%x", hex($base));
                                $tgtEndAddr = $interleaved ? '64\'h'.sprintf("%x", $maxInterleavedAddr) : '64\'h'.sprintf("%x", hex($base) + hex($range) - 1);

                                if($mappedRegionStr eq "") {
                                  $mappedRegionStr = "[$tgtStartAddr:$tgtEndAddr]";
                                }
                                else {
                                  $mappedRegionStr .= ", [$tgtStartAddr:$tgtEndAddr]";
                                }
                              }
                              if ($inclDbgReg) {
                                $mappedRegionStr .= ", [$dbgBaseAddr:$dbgEndAddr]";
                              }
                              print OUTFILE "\t\t\t\tif(domain_type == \"NON_SHAREABLE\") StartAddress inside {[start_address:end_address]};  \n";
                              print OUTFILE "\t\t\t\tif(domain_type == \"NON_SHAREABLE\") StartAddress + (Length*BurstSize) <= end_address;  \n";
                              print OUTFILE "\t\t\t\tif(domain_type != \"NON_SHAREABLE\") !(StartAddress inside {$mappedRegionStr});  \n";
                            } else {
                              print OUTFILE "\t\t\t\tStartAddress inside {[start_address:end_address]};  \n";
                              print OUTFILE "\t\t\t\tStartAddress + (Length*BurstSize) <= end_address;  \n";
                            }
                            print OUTFILE "\t\t\t}); \n";
                            print OUTFILE "  \t`uvm_send(burst) \n";

                            $loop++;
                        }
                    }
                    if($aceIEACnt || $rReorder || $wReorder || $inclDbgReg) {
                      print OUTFILE "   \tend else if (in_port_name == \"$iea\") begin \n";
                      
                      my $mappedRegionStr = "";
                      foreach my $amapInfo (@{$axi4IeaInfo{$iea}->{aMap}}) {
                        my $base = sprintf("0x%X", $amapInfo->{baseAddr});
                        my $mask = hex(sprintf("0x%X", $amapInfo->{mask}));
                        my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                        if ($base==0 && $mask==0) {
                          $range = sprintf("0x%x", (1<<(int($axi4IeaInfo{$iea}->{addrW}))));
                        }
                        
                        my $rangeMask = (1 << (int($axi4IeaInfo{$iea}->{addrW}))) - 1;
                        my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                        my $interleavedBase = hex($base);
                        my $interleaved = 0;
                        while (($interleavedBase < $maxInterleavedAddr)){
                          if(($interleavedBase & $mask) == hex($base)){
                            if($interleavedBase != hex($base)){
                              $interleaved++;
                              last;
                            }
                          }
                          $interleavedBase = $interleavedBase + hex($range);
                        }                              
                        $tgtStartAddr = '64\'h'.sprintf("%x", hex($base));
                        $tgtEndAddr = $interleaved ? '64\'h'.sprintf("%x", $maxInterleavedAddr) : '64\'h'.sprintf("%x", hex($base) + hex($range) - 1);
                        
                        if($mappedRegionStr eq "") {
                          $mappedRegionStr = "[$tgtStartAddr:$tgtEndAddr]";
                        }
                        else {
                          $mappedRegionStr .= ", [$tgtStartAddr:$tgtEndAddr]";
                        }
                      }
                      if ($inclDbgReg) {
                        $mappedRegionStr .= ", [$dbgBaseAddr:$dbgEndAddr]";
                      }
                      print OUTFILE "   \t\tvoid'(burst.randomize() with { \n";
                      if($rReorder){
                        print OUTFILE "\t\t\t\tif(Direction == DENALI_CDN_AXI_DIRECTION_READ) Length <= $maxRDP;  \n";
                      }
                      if($aceIEACnt || $inclDbgReg){
                        print OUTFILE "\t\t\t\t!(StartAddress inside {$mappedRegionStr});  \n";
                      } else {
                        print OUTFILE "\t\t\t\tStartAddress inside {[start_address:end_address]};  \n";
                        print OUTFILE "\t\t\t\tStartAddress + (Length*BurstSize) <= end_address;  \n";
                      }
                      print OUTFILE "\t\t\t}); \n";
                      print OUTFILE "  \t`uvm_send(burst) \n";
                   }
                }

                print OUTFILE "  \tend else begin \n";
                print OUTFILE "  \t\tsuper.do_item(); // default behaviour for all other cases \n";
                print OUTFILE "  \tend \n";

                print OUTFILE " \n";
                print OUTFILE " \n";
                print OUTFILE "  endtask \n";

                if ((($line =~ /\/\/ Factory overrides registration/) && ($add_axiiea_constraints))) {
                    print OUTFILE "endclass \n";
                    print OUTFILE " \n";
                    print OUTFILE " \n";
                    print OUTFILE " function __register_axi_seq(); \n";
                    print OUTFILE " cdn_axi_master_single_trans_seq::type_id::set_type_override(cdn_axi_master_single_trans_seq_user::get_type()); \n";
                    print OUTFILE " return 1;  \n";
                    print OUTFILE " endfunction  \n";
                    print OUTFILE " bit called_register_axi_seq_override = __register_axi_seq();  \n";
                    $in_usr_axi_dwn_sizing = 0;
                }
                $add_axiiea_constraints = 0;
            }

            if (   ($line =~ /class cdn_ahb_master_single_trans_seq_user extends cdn_ahb_master_single_trans_seq;/)
                || (($line =~ /\/\/ Factory overrides registration/) && ($add_ahbiea_constraints))) {
                $in_usr_ahb_dwn_sizing = 1;
                print OUTFILE "class cdn_ahb_master_single_trans_seq_user extends cdn_ahb_master_single_trans_seq; \n\n";
                print OUTFILE "   bit disable_constraints = 1'b0; \n";
                print OUTFILE "   bit allow_illegals = 1'b0; \n";
                print OUTFILE "   bit add_for_ace = 1'b0; \n";
                print OUTFILE "   cdn_stg_addr_t non_shareable_base[\$], inner_shareable_base[\$], outer_shareable_base[\$], system_shareable_base[\$];\n";
                print OUTFILE "   cdn_stg_addr_t non_shareable_end[\$], inner_shareable_end[\$], outer_shareable_end[\$], system_shareable_end[\$];\n";
                print OUTFILE "   string domain_type;\n";
                print OUTFILE "   int index = 0;\n\n";
                print OUTFILE "   `uvm_object_utils(cdn_ahb_master_single_trans_seq_user) \n\n";
                print OUTFILE "   function new(string name = \"cdn_ahb_master_single_trans_seq_user\"); \n";
                print OUTFILE "      string testname; \n";
                print OUTFILE "      super.new(name); \n";
                print OUTFILE "      if(\$value\$plusargs(\"UVM_TESTNAME=%s\", testname)) begin\n";
                print OUTFILE "         if (testname == \"min_latency_test\" || testname == \"max_bandwidth_test\" || testname == \"ot_sweep_test\") begin \n";
                print OUTFILE "             disable_constraints = 1'b1; \n";
                print OUTFILE "         end else if (testname == \"all_masters_random_segments_test\" || testname == \"single_master_random_segments_test\" || testname == \"all_masters_unmapped_segments_test\" || testname == \"single_master_unmapped_segments_test\") begin \n";
                print OUTFILE "             add_for_ace = 1'b1; \n";
                print OUTFILE "         end; \n";
                print OUTFILE "      end; \n";
                print OUTFILE "      if(\$test\$plusargs(\"allow_illegals\")) begin\n";
                print OUTFILE "         allow_illegals = 1'b1; \n";
                print OUTFILE "      end; \n";
                print OUTFILE "   endfunction : new \n";

                print OUTFILE "   virtual task do_item();\n";
                print OUTFILE "   \tbit rand_illegal = (\$urandom_range(1, 10) < 3); \n";
                print OUTFILE "   \tburst = cdnStg_ahbTransaction::type_id::create(\"burst\", p_sequencer);\n";
                print OUTFILE "   \tburst.set_item_context(this, p_sequencer);\n";

                print OUTFILE "   \tif (disable_constraints || allow_illegals && rand_illegal) begin \n";
                print OUTFILE "   \t\tsuper.do_item(); // default behaviour for all other cases \n";
                
                foreach my $iea (keys %ahbIeaInfo) {
                  my $ahbiea_addrw = $ahbIeaInfo{$iea}->{addrW};
                  my $max_addr = sprintf("64'h%x", ((1<<$ahbiea_addrw)-1));
                  if (grep {$_ eq "*ID0"} @{ $ahbIeaInfo{$iea}->{targets}}) {
                      my $dbgBaseAddr = sprintf("%d'h%x", $ahbIeaInfo{$iea}->{addrW}, $dbgBase);
                      print OUTFILE "   \tend else if (in_port_name == \"$iea\" && start_address == $dbgBaseAddr) begin \n";
                      print OUTFILE "   \t\tvoid'(burst.randomize() with { \n";
                      print OUTFILE "\t\t\t\t\tSize == DENALI_CDN_AHB_TRANSFERSIZE_WORD;\n";
                      print OUTFILE "\t\t\t\t\tFirstAddress[1:0] == 'h0;\n";
                      print OUTFILE "\t\t\t\t\tFirstAddress inside {[start_address:end_address]};  \n";
                      print OUTFILE "\t\t\t}); \n";
                      print OUTFILE "  \t`uvm_send(burst) \n";
                  }
                  foreach my $tea (@{ $ahbIeaInfo{$iea}->{targets} }) {
                    next if ($tea eq "*ID0");
                    my $ieaSize = $ahbIeaInfo{$iea}->{dataW} / 8;
                    #Targets need not be AHB so use general teaInfo for target parameters
                    my $teaSize  = $teaInfo{$tea}->{dataW} / 8;
                    my $teaAddrW = $teaInfo{$tea}->{addrW};
                    my $teaBus   = $teaInfo{$tea}->{bus};
                    if (   ($teaBus eq "AXI4" || $teaBus eq "ACELite")
                        || ($teaBus eq "APB")
                        || ($teaBus eq "AHB")) {
                        print OUTFILE "   \t\tend else if (in_port_name == \"$iea\" && out_port_name == \"$tea\") begin \n";

                        print OUTFILE "     \t\tnon_shareable_base = {};\n";
                        print OUTFILE "     \t\tinner_shareable_base = {};\n";
                        print OUTFILE "     \t\touter_shareable_base = {};\n";
                        print OUTFILE "     \t\tsystem_shareable_base = {};\n\n";
                        print OUTFILE "     \t\tnon_shareable_end = {};\n";
                        print OUTFILE "     \t\tinner_shareable_end = {};\n";
                        print OUTFILE "     \t\touter_shareable_end = {};\n";
                        print OUTFILE "     \t\tsystem_shareable_end = {};\n\n";

                        foreach my $amapEntry (@{$ahbIeaInfo{$iea}->{aMap}}) {
                          my $tea = $amapEntry->{tgt};
                          next if ($tea eq "*ID0");
                          my $base = sprintf("0x%X", $amapEntry->{baseAddr});
                          my $addr = '64\'h'.sprintf("%x", hex($base));
                          my $mask = hex(sprintf("0x%X", $amapEntry->{mask}));
                          my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                          if ($base==0 && $mask==0) {
                            $range = sprintf("0x%x", (1<<(int($ahbIeaInfo{$iea}->{addrW}))));
                          }
                          
                          if($aceIEACnt) {
                            my $tgtFound = 0;
                            foreach my $tgt (@aceTargets){
                              if($tgt->{tgt} eq $tea){
                                $tgtFound = 1;
                                my $bus = $tgt->{bus};
                                my $minRange;
                                my $eachRegionRange;
                                my $regionAddr;
                                if($bus eq "AHBACE") {
                                  $minRange = "0x1000";         #For AHB Slave Min Region is considered 1K, so check for 4K
                                  $eachRegionRange = "0x400";
                                } elsif ($bus eq "AXIACE") {
                                  $minRange = "0x4000";         #For AXI Slave Min Region is considered 4K, so check for 16K
                                  $eachRegionRange = "0x1000";
                                }
                                    
                                # Support for Interleaved Configurations
                                my $rangeMask = (1 << (int($ahbIeaInfo{$iea}->{addrW}))) - 1;
                                my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                my $interleavedBase = hex($base);
                                my $pushCnt = 0;
                                my $interleaved = 0;
                                while (($interleavedBase < $maxInterleavedAddr)){
                                  if(($interleavedBase & $mask) == hex($base)){
                                    if($interleavedBase != hex($base)){
                                      $interleaved++;
                                      last;
                                    }
                                  }
                                  $interleavedBase = $interleavedBase + hex($range);
                                }
                                my $interleavedEntries = $interleaved ? int((($maxInterleavedAddr + 1) - hex($base)) / ($interleavedBase - hex($base))) : 0;
                                if($interleavedEntries > 0 && $interleavedEntries <= 16) {   # All Entries would be part of Routing Table
                                  $interleavedBase = hex($base);
                                  my $pushCnt = 0;
                                  while ($interleavedBase < $maxInterleavedAddr){
                                    if(($interleavedBase & $mask) == hex($base)){
                                      $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                      $regionEndAddr = '64\'h'.sprintf("%x", $interleavedBase+hex($range));
                                      if(int($pushCnt%4) == 0) {
                                        print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tnon_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      elsif(int($pushCnt%4) == 1) {
                                        print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tinner_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      elsif(int($pushCnt%4) == 2) {
                                        print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\touter_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      elsif(int($pushCnt%4) == 3) {
                                        print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tsystem_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      $pushCnt++;
                                    }
                                    $interleavedBase = $interleavedBase + hex($range);
                                  } 
                                }
                                elsif($interleavedEntries > 16){
                                  $interleavedBase = hex($base);
                                  while ($interleavedBase < $maxInterleavedAddr){
                                    if(($interleavedBase & $mask) == hex($base)){
                                      $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                      $regionEndAddr = '64\'h'.sprintf("%x", $interleavedBase+hex($range));
                                      if($interleavedBase < ($maxInterleavedAddr+1)/4) {
                                        print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tnon_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      elsif($interleavedBase >= ($maxInterleavedAddr+1)/4 && $interleavedBase < ($maxInterleavedAddr+1)/2) {
                                        print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tinner_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      elsif($interleavedBase >= ($maxInterleavedAddr+1)/2 && $interleavedBase < ($maxInterleavedAddr+1)*3/4) {
                                        print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\touter_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                      elsif($interleavedBase >= ($maxInterleavedAddr+1)*3/4 && $interleavedBase < ($maxInterleavedAddr+1)) {
                                        print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tsystem_shareable_end.push_back(${regionEndAddr});\n";
                                      }
                                    }
                                    $interleavedBase = $interleavedBase + hex($range);
                                  }
                                }
                                else {
                                  if(hex($range) >= hex($minRange)){    
                                    #Divide into Equal 4 Regions
                                    print OUTFILE "     \t\tnon_shareable_base.push_back(${addr});\n";
                                    print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4).");\n";

                                    $regionAddr = hex($base) + hex($range)/4;
                                    $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                    print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                    print OUTFILE "     \t\tinner_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4).");\n";

                                    $regionAddr = hex($base) + hex($range)/4 + hex($range)/4;
                                    $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                    print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                    print OUTFILE "     \t\touter_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4).");\n";

                                    $regionAddr = hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4;
                                    $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                    print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                    print OUTFILE "     \t\tsystem_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4 + hex($range)/4).");\n";
                                  } 
                                  elsif (hex($range) < hex($minRange)){
                                    $regionRange = hex($eachRegionRange);
                                    $regionRange = '0x'.sprintf("%x", $regionRange);
                                    print OUTFILE "     \t\tnon_shareable_base.push_back(${addr});\n";
                                    print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange)).");\n";

                                    if((hex($range) - hex($eachRegionRange)) >=  hex($eachRegionRange)) {
                                      $regionAddr = hex($base) + hex($eachRegionRange);
                                      $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                      print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                      print OUTFILE "     \t\tinner_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange) + hex($eachRegionRange)).");\n";
                                    }

                                    if((hex($range) - 2*hex($eachRegionRange)) >=  hex($eachRegionRange)) {
                                      $regionAddr = hex($base) + hex($eachRegionRange) + hex($eachRegionRange);
                                      $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                      print OUTFILE "     \touter_shareable_base.push_back(${regionAddr});\n";
                                      print OUTFILE "     \t\touter_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange) + hex($eachRegionRange) + hex($eachRegionRange)).");\n";
                                    }
                                  }
                                }
                              }
                            }
                            if($tgtFound == 0){
                              # Supportfor Interleaved Configurations
                              my $rangeMask = (1 << (int($ahbIeaInfo{$iea}->{addrW}))) - 1;
                              my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                              my $interleavedBase = hex($base);
                              while ($interleavedBase < $maxInterleavedAddr){
                                if(($interleavedBase & $mask) == hex($base)){
                                  $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                  print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                  print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", $interleavedBase + hex($range)).");\n";
                                }
                                $interleavedBase = $interleavedBase + hex($range);
                              } 
                            }
                          } else {
                            my $rangeMask = (1 << (int($ahbIeaInfo{$iea}->{addrW}))) - 1;
                            my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                            my $interleavedBase = hex($base);
                            while ($interleavedBase < $maxInterleavedAddr){
                              if(($interleavedBase & $mask) == hex($base)){
                                $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", $interleavedBase + hex($range)).");\n";
                              }
                              $interleavedBase = $interleavedBase + hex($range);
                            }
                          }
                        }
                       
                        print OUTFILE "\n     \t\tforeach (non_shareable_base[i]) begin\n";
                        print OUTFILE "     \t\t\tif(non_shareable_base[i] <= start_address && non_shareable_end[i] > start_address) begin\n";
                        print OUTFILE "     \t\t\t\tdomain_type = \"NON_SHAREABLE\";\n";
                        print OUTFILE "     \t\t\t\tindex = 1;\n";
                        print OUTFILE "     \t\t\t\tbreak;\n";
                        print OUTFILE "     \t\t\tend\n";
                        print OUTFILE "     \t\tend\n";
                        print OUTFILE "     \t\tif(index == 0) begin\n";
                        print OUTFILE "     \t\t\tforeach (inner_shareable_base[i]) begin\n";
                        print OUTFILE "     \t\t\t\tif(inner_shareable_base[i] <= start_address && inner_shareable_end[i] > start_address) begin\n";
                        print OUTFILE "     \t\t\t\t\tdomain_type = \"INNER_SHAREABLE\";\n";
                        print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                        print OUTFILE "     \t\t\t\t\tbreak;\n";
                        print OUTFILE "     \t\t\t\tend\n";
                        print OUTFILE "     \t\t\tend\n";
                        print OUTFILE "     \t\tend\n";
                        print OUTFILE "     \t\tif(index == 0) begin\n";
                        print OUTFILE "     \t\t\tforeach (outer_shareable_base[i]) begin\n";
                        print OUTFILE "     \t\t\t\tif(outer_shareable_base[i] <= start_address && outer_shareable_end[i] > start_address) begin\n";
                        print OUTFILE "     \t\t\t\t\tdomain_type = \"OUTER_SHAREABLE\";\n";
                        print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                        print OUTFILE "     \t\t\t\t\tbreak;\n";
                        print OUTFILE "     \t\t\t\tend\n";
                        print OUTFILE "     \t\t\tend\n";
                        print OUTFILE "     \t\tend\n";
                        print OUTFILE "     \t\tif(index == 0) begin\n";
                        print OUTFILE "     \t\t\tforeach (system_shareable_base[i]) begin\n";
                        print OUTFILE "     \t\t\t\tif(system_shareable_base[i] <= start_address && system_shareable_end[i] > start_address) begin\n";
                        print OUTFILE "     \t\t\t\t\tdomain_type = \"SYSTEM_SHAREABLE\";\n";
                        print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                        print OUTFILE "     \t\t\t\t\tbreak;\n";
                        print OUTFILE "     \t\t\t\tend\n";
                        print OUTFILE "     \t\t\tend\n";
                        print OUTFILE "     \t\tend\n";
                            
                        my $ismapped = 1;
                        my $ieaace = $ieaInfo{$iea}->{ace};
                        if(!$ieaace){
                           $ismapped = 0;
                        }

                        print OUTFILE "     \t\t`uvm_rand_send_with(burst, {\n";

                        if ($teaBus eq "APB") {
                            #print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_SINGLE) 2**(Size-1) == $teaSize;\n"; 
                            #print OUTFILE "\t\t\t\t\tSize == DENALI_CDN_AHB_TRANSFERSIZE_WORD;\n";
                            #print OUTFILE "\t\t\t\t\tFirstAddress[1:0] == 'h0;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_SINGLE) 2**(Size-1) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP4) 4*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP8) 8*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP16) 16*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR4) 4*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR8) 8*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR16) 16*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR) (2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\t//CacheMode == DENALI_CDN_AHB_CACHEMODE_NO_CACHE;\n";
                            print OUTFILE "\t\t\t\t\tShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_NO_SHAREABLE;\n";
                        }
                        if ($teaBus eq "AHB") {
                            #print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_SINGLE) 2**(Size-1) <= $teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_SINGLE) 2**(Size-1) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP4) 4*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP8) 8*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP16) 16*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR4) 4*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR8) 8*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR16) 16*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR) (2**(Size-1)) <= 256*$teaSize;\n";
                            my $ace = $teaInfo{$tea}->{ace};
                            if($ace == 0){
                              print OUTFILE "\t\t\t\t\tShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_NO_SHAREABLE;\n";
                            } else {
                              print OUTFILE "\t\t\t\t\tif(domain_type == \"NON_SHAREABLE\" || domain_type == \"SYSTEM_SHAREABLE\") ShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_NO_SHAREABLE;\n"; 
                              print OUTFILE "\t\t\t\t\telse ShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_SHAREABLE;\n"; 
                            }
                        }
                        if ($teaBus eq "AXI4" || $teaBus eq "ACELite" || $teaBus eq "APB") {
                            #print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_SINGLE) 2**(Size-1) <= $teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_SINGLE) 2**(Size-1) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP4) 4*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP8) 8*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_WRAP16) 16*(2**(Size-1)) <= 16*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR4) 4*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR8) 8*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR16) 16*(2**(Size-1)) <= 256*$teaSize;\n";
                            print OUTFILE "\t\t\t\t\tif(Kind == DENALI_CDN_AHB_BURSTKIND_INCR) (2**(Size-1)) <= 256*$teaSize;\n";
                            
                            if($teaBus ne "ACELite"){
                              print OUTFILE "\t\t\t\t\tShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_NO_SHAREABLE;\n";
                            } else {
                              print OUTFILE "\t\t\t\t\tif(domain_type == \"NON_SHAREABLE\" || domain_type == \"SYSTEM_SHAREABLE\") ShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_NO_SHAREABLE;\n"; 
                              print OUTFILE "\t\t\t\t\telse ShareableMode == DENALI_CDN_AHB_SHAREABLEMODE_SHAREABLE;\n"; 
                            }
                        }

                        my $mappedRegionStr = "";
                        foreach my $amapInfo (@{$ahbIeaInfo{$iea}->{aMap}}) {
                          my $base = sprintf("0x%X", $amapInfo->{baseAddr});
                          my $mask = hex(sprintf("0x%X", $amapInfo->{mask}));
                          my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                          if ($base==0 && $mask==0) {
                            $range = sprintf("0x%x", (1<<(int($ahbIeaInfo{$iea}->{addrW}))));
                          }
                          my $rangeMask = (1 << (int($ahbIeaInfo{$iea}->{addrW}))) - 1;
                          my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                          my $interleavedBase = hex($base);
                          my $interleaved = 0;
                          while (($interleavedBase < $maxInterleavedAddr)){
                            if(($interleavedBase & $mask) == hex($base)){
                              if($interleavedBase != hex($base)){
                                $interleaved++;
                                last;
                              }
                            }
                            $interleavedBase = $interleavedBase + hex($range);
                          }                              
                          $tgtStartAddr = '64\'h'.sprintf("%x", hex($base));
                          $tgtEndAddr = $interleaved ? '64\'h'.sprintf("%x", $maxInterleavedAddr) : '64\'h'.sprintf("%x", hex($base) + hex($range) - 1);
                          
                          if($mappedRegionStr eq "") {
                            $mappedRegionStr = "[$tgtStartAddr:$tgtEndAddr]";
                          }
                          else {
                            $mappedRegionStr .= ", [$tgtStartAddr:$tgtEndAddr]";
                          }
                        }

                      #STG doesn't set address width in configuration and even if we add it to the configuration VIP randomization doesn't follow it.
                      #If a certain address is required not to be inside some range e.g. 64'h0:64'h1FFF and the address width is smaller than 64 e.g. 13 bits, 
                      #Then the randomized FirstAddr can have a value 64'h41000 and actual driven address would be in the range which is not allowed.
                      #We are adding following constraint to avoid this, ideally this should be a VIP constraint (the soft constraint they have doesn't impact this)
                        print OUTFILE "\t\t\t\tFirstAddress inside {[0:$max_addr]};  \n";
                        if(!$ismapped) {
                          print OUTFILE "\t\t\t\tif(domain_type == \"NON_SHAREABLE\") FirstAddress inside {[start_address:end_address]};  \n";
                          print OUTFILE "\t\t\t\telse !(FirstAddress inside {$mappedRegionStr});  \n";
                        } else {
                          print OUTFILE "\t\t\t\t\tif(domain_type == \"OUTER_SHAREABLE\") !(FirstAddress inside {$mappedRegionStr});  \n";
                          print OUTFILE "\t\t\t\t\telse FirstAddress inside {[start_address:end_address]};  \n";
                        }
                        print OUTFILE "\t\t\t\t}) \n";
                        
                        $loop++;
                      }
                    }
                    if($aceIEACnt || $inclDbgReg) {
                      print OUTFILE "   \t\tend else if (in_port_name == \"$iea\") begin \n";

                      my $mappedRegionStr = "";
                      foreach my $amapInfo (@{$ahbIeaInfo{$iea}->{aMap}}) {
                        my $base = sprintf("0x%X", $amapInfo->{baseAddr});
                        my $mask = hex(sprintf("0x%X", $amapInfo->{mask}));
                        my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                        if ($base==0 && $mask==0) {
                          $range = sprintf("0x%x", (1<<(int($ahbIeaInfo{$iea}->{addrW}))));
                        }
                        my $rangeMask = (1 << (int($ahbIeaInfo{$iea}->{addrW}))) - 1;
                        my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                        my $interleavedBase = hex($base);
                        my $interleaved = 0;
                        while (($interleavedBase < $maxInterleavedAddr)){
                          if(($interleavedBase & $mask) == hex($base)){
                            if($interleavedBase != hex($base)){
                              $interleaved++;
                              last;
                            }
                          }
                          $interleavedBase = $interleavedBase + hex($range);
                        }                              
                        $tgtStartAddr = '64\'h'.sprintf("%x", hex($base));
                        $tgtEndAddr = $interleaved ? '64\'h'.sprintf("%x", $maxInterleavedAddr) : '64\'h'.sprintf("%x", hex($base) + hex($range) - 1);
                         
                        if($mappedRegionStr eq "") {
                          $mappedRegionStr = "[$tgtStartAddr:$tgtEndAddr]";
                        }
                        else {
                          $mappedRegionStr .= ", [$tgtStartAddr:$tgtEndAddr]";
                        }
                      }
                      if ($inclDbgReg) {
                        my $dbgBaseAddr = sprintf("64\'h%x", $dbgBase);
                        my $dbgEndAddr = sprintf("64\'h%x", $dbgBase+4095);
                        $mappedRegionStr .= ", [$dbgBaseAddr:$dbgEndAddr]";
                      }
                      print OUTFILE "\t\t\t\t`uvm_rand_send_with(burst, {\n";
                      #STG doesn't set address width in configuration and even if we add it to the configuration VIP randomization doesn't follow it.
                      #If a certain address is required not to be inside some range e.g. 64'h0:64'h1FFF and the address width is smaller than 64 e.g. 13 bits, 
                      #Then the randomized FirstAddr can have a value 64'h41000 and actual driven address would be in the range which is not allowed.
                      #We are adding following constraint to avoid this, ideally this should be a VIP constraint (the soft constraint they have doesn't impact this)
                      print OUTFILE "\t\t\t\t\tFirstAddress inside {[0:$max_addr]};  \n";
                      print OUTFILE "\t\t\t\t\t!(FirstAddress inside {$mappedRegionStr});  \n";
                      print OUTFILE "\t\t\t\t}) \n";
                    }
                  }
                    
                  print OUTFILE "  \t\tend else begin \n";
                  print OUTFILE "  \t\t\tsuper.do_item(); // default behaviour for all other cases \n";
                  print OUTFILE "  \t\tend \n";
                  print OUTFILE "endtask\n";
 
                  if ((($line =~ /\/\/ Factory overrides registration/) && ($add_ahbiea_constraints))) {
                       print OUTFILE "endclass \n";
                       print OUTFILE " \n";
                       print OUTFILE " \n";
                       print OUTFILE " function __register_ahb_seq(); \n";
                       print OUTFILE " cdn_ahb_master_single_trans_seq::type_id::set_type_override(cdn_ahb_master_single_trans_seq_user::get_type()); \n";
                       print OUTFILE " return 1;  \n";
                       print OUTFILE " endfunction  \n";
                       print OUTFILE " bit called_register_ahb_seq_override = __register_ahb_seq();  \n";
                       $in_usr_ahb_dwn_sizing = 0;
                   }
                   $add_ahbiea_constraints = 0;
                }                

            if (($line =~ /endclass/) && $in_usr_axi_dwn_sizing) {
                $in_usr_axi_dwn_sizing = 0;
            }
            
            if (($line =~ /endclass/) && $in_usr_ahb_dwn_sizing) {
                $in_usr_ahb_dwn_sizing = 0;
            }
            
            if ($line =~ /endclass : apbTransactionUsr/) {
                $apb_add_rw_logic = 1;
            }    

            if ($apb_add_rw_logic) {
                print OUTFILE "endclass : apbTransactionUsr\n";
                my $add_apb_trans_seq_user = 1; # This sequence is always needed to support ACELite Constraints
                my $loop                   = 0;
                if ($add_apb_trans_seq_user) {
                    print OUTFILE "//-------------------------------------------------------------------------------- \n";
                    print OUTFILE "//-- a SINGLE_TRANS master sequence, doing a single burst to a given address \n";
                    print OUTFILE "//-------------------------------------------------------------------------------- \n";
                    print OUTFILE "class cdn_apb_master_single_trans_seq_user extends cdn_apb_master_single_trans_seq; \n";
                    print OUTFILE " \n";
                    print OUTFILE " \n";
                    print OUTFILE "   `uvm_object_utils(cdn_apb_master_single_trans_seq_user) \n";
                    print OUTFILE " \n";
                    print OUTFILE "   bit disable_constraints = 1'b0; \n";
                    print OUTFILE "   bit allow_illegals = 1'b0; \n";
                    print OUTFILE "   bit add_for_ace = 1'b0; \n";
                    print OUTFILE "   cdn_stg_addr_t non_shareable_base[\$], inner_shareable_base[\$], outer_shareable_base[\$], system_shareable_base[\$];\n";
                    print OUTFILE "   cdn_stg_addr_t non_shareable_end[\$], inner_shareable_end[\$], outer_shareable_end[\$], system_shareable_end[\$];\n";
                    print OUTFILE "   string domain_type;\n";
                    print OUTFILE "   int index = 0;\n";
                    print OUTFILE " \n";
                    print OUTFILE "   function new (string name = \"cdn_apb_master_single_trans_seq_user\"); \n";
                    print OUTFILE "      string testname; \n";
                    print OUTFILE "      super.new(name); \n";
                    print OUTFILE "      if(\$value\$plusargs(\"UVM_TESTNAME=%s\", testname)) begin\n";
                    print OUTFILE "         if (testname == \"min_latency_test\" || testname == \"max_bandwidth_test\" || testname == \"ot_sweep_test\") begin \n";
                    print OUTFILE "             disable_constraints = 1'b1; \n";
                    print OUTFILE "         end else if (testname == \"all_masters_random_segments_test\" || testname == \"single_master_random_segments_test\" || testname == \"all_masters_unmapped_segments_test\" || testname == \"single_master_unmapped_segments_test\") begin \n";
                    print OUTFILE "             add_for_ace = 1'b1; \n";
                    print OUTFILE "         end; \n";
                    print OUTFILE "      end; \n";
                    print OUTFILE "      if(\$test\$plusargs(\"allow_illegals\")) begin\n";
                    print OUTFILE "         allow_illegals = 1'b1; \n";
                    print OUTFILE "      end; \n";
                    print OUTFILE "   endfunction : new \n";
                    print OUTFILE " \n";
                    print OUTFILE " \n";
                    print OUTFILE "   virtual task do_item(); \n";
                    print OUTFILE "   \tbit rand_illegal = (\$urandom_range(1, 10) < 3); \n";
                    print OUTFILE "   \t`uvm_create(burst) \n";
                    print OUTFILE "  	burst.set_item_context(this, p_sequencer);   \n";

                    print OUTFILE "   \tif (disable_constraints || allow_illegals && rand_illegal) begin \n";
                    print OUTFILE "   \t\tsuper.do_item(); // default behaviour for all other cases \n";
                    
                    foreach my $iea (keys %apbIeaInfo) {
                      my $ieaSize = $apbIeaInfo{$iea}->{dataW} / 8;
                      my $apb_direction = $apbIeaInfo{$iea}->{rw};
                      my $apbiea_addrw = $apbIeaInfo{$iea}->{addrW};
                      my $max_addr = sprintf("64'h%x", ((1<<$apbiea_addrw)-1));
                      foreach my $tea (@{ $apbIeaInfo{$iea}->{targets} }) {

                        #Targets need not be APB so use general teaInfo for target parameters
                        my $teaSize  = $teaInfo{$tea}->{dataW} / 8;

                        my $teaAddrW = $teaInfo{$tea}->{addrW};
                        my $teaBus   = $teaInfo{$tea}->{bus};
                        next if ($tea eq "*ID0");
                        if (   ($teaBus eq "AXI4" || $teaBus eq "ACELite")
                            || ($teaBus eq "APB")
                            || ($teaBus eq "AHB")) {
                            print OUTFILE "   \t\tend else if (in_port_name == \"$iea\" && out_port_name == \"$tea\") begin \n";

                            print OUTFILE "     \t\tnon_shareable_base = {};\n";
                            print OUTFILE "     \t\tinner_shareable_base = {};\n";
                            print OUTFILE "     \t\touter_shareable_base = {};\n";
                            print OUTFILE "     \t\tsystem_shareable_base = {};\n\n";
                            print OUTFILE "     \t\tnon_shareable_end = {};\n";
                            print OUTFILE "     \t\tinner_shareable_end = {};\n";
                            print OUTFILE "     \t\touter_shareable_end = {};\n";
                            print OUTFILE "     \t\tsystem_shareable_end = {};\n\n";

                            foreach my $amapEntry (@{$apbIeaInfo{$iea}->{aMap}}) {
                              my $tea = $amapEntry->{tgt};
                              next if ($tea eq "*ID0");
                              my $base = sprintf("0x%X", $amapEntry->{baseAddr});
                              my $addr = '64\'h'.sprintf("%x", hex($base));
                              my $mask = hex(sprintf("0x%X", $amapEntry->{mask}));
                              my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                              if ($base==0 && $mask==0) {
                                $range = sprintf("0x%x", (1<<(int($apbIeaInfo{$iea}->{addrW}))));
                              }
                              
                              if($aceIEACnt) {
                                my $tgtFound = 0;
                                foreach my $tgt (@aceTargets){
                                  if($tgt->{tgt} eq $tea){
                                    $tgtFound = 1;
                                    my $bus = $tgt->{bus};
                                    my $minRange;
                                    my $eachRegionRange;
                                    my $regionAddr;
                                    if($bus eq "AHBACE") {
                                      $minRange = "0x1000";         #For AHB Slave Min Region is considered 1K, so check for 4K
                                      $eachRegionRange = "0x400";
                                    } elsif ($bus eq "AXIACE") {
                                      $minRange = "0x4000";         #For AXI Slave Min Region is considered 4K, so check for 16K
                                      $eachRegionRange = "0x1000";
                                    }

                                    # Support for Interleaved Configurations
                                    my $rangeMask = (1 << (int($apbIeaInfo{$iea}->{addrW}))) - 1;
                                    my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                    my $interleavedBase = hex($base);
                                    my $pushCnt = 0;
                                    my $interleaved = 0;
                                    while (($interleavedBase < $maxInterleavedAddr)){
                                      if(($interleavedBase & $mask) == hex($base)){
                                        if($interleavedBase != hex($base)){
                                          $interleaved++;
                                          last;
                                        }
                                      }
                                      $interleavedBase = $interleavedBase + hex($range);
                                    }
                                    my $interleavedEntries = $interleaved ? int((($maxInterleavedAddr + 1) - hex($base)) / ($interleavedBase - hex($base))) : 0;
                                    if($interleavedEntries > 0 && $interleavedEntries <= 16) {   # All Entries would be part of Routing Table
                                      $interleavedBase = hex($base);
                                      my $pushCnt = 0;
                                      while ($interleavedBase < $maxInterleavedAddr){
                                        if(($interleavedBase & $mask) == hex($base)){
                                          $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                          $regionEndAddr = '64\'h'.sprintf("%x", $interleavedBase+hex($range));
                                          if(int($pushCnt%4) == 0) {
                                            print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tnon_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif(int($pushCnt%4) == 1) {
                                            print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tinner_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif(int($pushCnt%4) == 2) {
                                            print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\touter_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif(int($pushCnt%4) == 3) {
                                            print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tsystem_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          $pushCnt++;
                                        }
                                        $interleavedBase = $interleavedBase + hex($range);
                                      } 
                                    }
                                    elsif($interleavedEntries > 16){
                                      $interleavedBase = hex($base);
                                      while ($interleavedBase < $maxInterleavedAddr){
                                        if(($interleavedBase & $mask) == hex($base)){
                                          $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                          $regionEndAddr = '64\'h'.sprintf("%x", $interleavedBase+hex($range));
                                          if($interleavedBase < ($maxInterleavedAddr+1)/4) {
                                            print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tnon_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif($interleavedBase >= ($maxInterleavedAddr+1)/4 && $interleavedBase < ($maxInterleavedAddr+1)/2) {
                                            print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tinner_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif($interleavedBase >= ($maxInterleavedAddr+1)/2 && $interleavedBase < ($maxInterleavedAddr+1)*3/4) {
                                            print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\touter_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                          elsif($interleavedBase >= ($maxInterleavedAddr+1)*3/4 && $interleavedBase < ($maxInterleavedAddr+1)) {
                                            print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                            print OUTFILE "     \t\tsystem_shareable_end.push_back(${regionEndAddr});\n";
                                          }
                                        }
                                        $interleavedBase = $interleavedBase + hex($range);
                                      }
                                    }
                                    else {
                                      if(hex($range) >= hex($minRange)){    
                                        #Divide into Equal 4 Regions
                                        print OUTFILE "     \t\tnon_shareable_base.push_back(${addr});\n";
                                        print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4).");\n";

                                        $regionAddr = hex($base) + hex($range)/4;
                                        $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                        print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tinner_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4).");\n";

                                        $regionAddr = hex($base) + hex($range)/4 + hex($range)/4;
                                        $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                        print OUTFILE "     \t\touter_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\touter_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4).");\n";

                                        $regionAddr = hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4;
                                        $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                        print OUTFILE "     \t\tsystem_shareable_base.push_back(${regionAddr});\n";
                                        print OUTFILE "     \t\tsystem_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($range)/4 + hex($range)/4 + hex($range)/4 + hex($range)/4).");\n";
                                      } 
                                      elsif (hex($range) < hex($minRange)){
                                        $regionRange = hex($eachRegionRange);
                                        $regionRange = '0x'.sprintf("%x", $regionRange);
                                        print OUTFILE "     \t\tnon_shareable_base.push_back(${addr});\n";
                                        print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange)).");\n";

                                        if((hex($range) - hex($eachRegionRange)) >=  hex($eachRegionRange)) {
                                          $regionAddr = hex($base) + hex($eachRegionRange);
                                          $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                          print OUTFILE "     \t\tinner_shareable_base.push_back(${regionAddr});\n";
                                          print OUTFILE "     \t\tinner_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange) + hex($eachRegionRange)).");\n";
                                        }

                                        if((hex($range) - 2*hex($eachRegionRange)) >=  hex($eachRegionRange)) {
                                          $regionAddr = hex($base) + hex($eachRegionRange) + hex($eachRegionRange);
                                          $regionAddr = '64\'h'.sprintf("%x", $regionAddr);
                                          print OUTFILE "     \touter_shareable_base.push_back(${regionAddr});\n";
                                          print OUTFILE "     \t\touter_shareable_end.push_back(".sprintf("64'h%x", hex($base) + hex($eachRegionRange) + hex($eachRegionRange) + hex($eachRegionRange)).");\n";
                                        }
                                      }
                                    }
                                  }
                                }
                                if($tgtFound == 0){
                                  # Supportfor Interleaved Configurations
                                  my $rangeMask = (1 << (int($apbIeaInfo{$iea}->{addrW}))) - 1;
                                  my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                  my $interleavedBase = hex($base);
                                  while ($interleavedBase < $maxInterleavedAddr){
                                    if(($interleavedBase & $mask) == hex($base)){
                                      $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                      print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                      print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", $interleavedBase + hex($range)).");\n";
                                    }
                                    $interleavedBase = $interleavedBase + hex($range);
                                  } 
                                }
                              } else {
                                my $rangeMask = (1 << (int($apbIeaInfo{$iea}->{addrW}))) - 1;
                                my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                                my $interleavedBase = hex($base);
                                while ($interleavedBase < $maxInterleavedAddr){
                                  if(($interleavedBase & $mask) == hex($base)){
                                    $regionAddr = '64\'h'.sprintf("%x", $interleavedBase);
                                    print OUTFILE "     \t\tnon_shareable_base.push_back(${regionAddr});\n";
                                    print OUTFILE "     \t\tnon_shareable_end.push_back(".sprintf("64'h%x", $interleavedBase + hex($range)).");\n";
                                  }
                                  $interleavedBase = $interleavedBase + hex($range);
                                }
                              }
                            }
                       
                            print OUTFILE "\n     \t\tforeach (non_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\tif(non_shareable_base[i] <= start_address && non_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\tdomain_type = \"NON_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            print OUTFILE "     \t\tif(index == 0) begin\n";
                            print OUTFILE "     \t\t\tforeach (inner_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\t\tif(inner_shareable_base[i] <= start_address && inner_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\t\tdomain_type = \"INNER_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\t\tend\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            print OUTFILE "     \t\tif(index == 0) begin\n";
                            print OUTFILE "     \t\t\tforeach (outer_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\t\tif(outer_shareable_base[i] <= start_address && outer_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\t\tdomain_type = \"OUTER_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\t\tend\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            print OUTFILE "     \t\tif(index == 0) begin\n";
                            print OUTFILE "     \t\t\tforeach (system_shareable_base[i]) begin\n";
                            print OUTFILE "     \t\t\t\tif(system_shareable_base[i] <= start_address && system_shareable_end[i] > start_address) begin\n";
                            print OUTFILE "     \t\t\t\t\tdomain_type = \"SYSTEM_SHAREABLE\";\n";
                            print OUTFILE "     \t\t\t\t\tindex = 1;\n";
                            print OUTFILE "     \t\t\t\t\tbreak;\n";
                            print OUTFILE "     \t\t\t\tend\n";
                            print OUTFILE "     \t\t\tend\n";
                            print OUTFILE "     \t\tend\n";
                            
                            my $ismapped = 0;

                            print OUTFILE "     \t\t`uvm_rand_send_with(burst, {\n";
                           
                            my $mappedRegionStr = "";
                            foreach my $amapInfo (@{$apbIeaInfo{$iea}->{aMap}}) {
                              my $base = sprintf("0x%X", $amapInfo->{baseAddr});
                              my $mask = hex(sprintf("0x%X", $amapInfo->{mask}));
                              my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                              if ($base==0 && $mask==0) {
                                $range = sprintf("0x%x", (1<<(int($apbIeaInfo{$iea}->{addrW}))));
                              }
                              my $rangeMask = (1 << (int($apbIeaInfo{$iea}->{addrW}))) - 1;
                              my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                              my $interleavedBase = hex($base);
                              my $interleaved = 0;
                              while (($interleavedBase < $maxInterleavedAddr)){
                                if(($interleavedBase & $mask) == hex($base)){
                                  if($interleavedBase != hex($base)){
                                    $interleaved++;
                                    last;
                                  }
                                }
                                $interleavedBase = $interleavedBase + hex($range);
                              }                              
                              $tgtStartAddr = '64\'h'.sprintf("%x", hex($base));
                              $tgtEndAddr = $interleaved ? '64\'h'.sprintf("%x", $maxInterleavedAddr) : '64\'h'.sprintf("%x", hex($base) + hex($range) - 1);
                                
                              if($mappedRegionStr eq "") {
                                $mappedRegionStr = "[$tgtStartAddr:$tgtEndAddr]";
                              }
                              else {
                                $mappedRegionStr .= ", [$tgtStartAddr:$tgtEndAddr]";
                              }
                            }

                            if ($apb_direction ne 'rw') {
                              print OUTFILE "\t\t\t\tDirection == " . apb_direction($apb_direction) . "; \n";
                            }
                            if ($teaBus eq "AHB") {
                              print OUTFILE "\t\t\t\tAddr[1:0] == 2\'b0; \n";
                            }
                            #STG doesn't set address width in configuration and even if we add it to the configuration VIP randomization doesn't follow it.
                            #If a certain address is required not to be inside some range e.g. 64'h0:64'h1FFF and the address width is smaller than 64 e.g. 13 bits, 
                            #Then the randomized FirstAddr can have a value 64'h41000 and actual driven address would be in the range which is not allowed.
                            #We are adding following constraint to avoid this, ideally this should be a VIP constraint (the soft constraint they have doesn't impact this)
                            print OUTFILE "\t\t\t\tAddr inside {[0:$max_addr]};  \n";
                            print OUTFILE "\t\t\t\tif(domain_type == \"NON_SHAREABLE\") Addr inside {[start_address:end_address]};  \n";
                            print OUTFILE "\t\t\t\telse !(Addr inside {$mappedRegionStr});  \n";
                            print OUTFILE "\t\t\t\t}) \n";
                       
                            $loop++;
                          }
                        }
                        if($aceIEACnt) {
                          print OUTFILE "   \t\tend else if (in_port_name == \"$iea\") begin \n";

                          my $mappedRegionStr = "";
                          foreach my $amapInfo (@{$apbIeaInfo{$iea}->{aMap}}) {
                            my $base = sprintf("0x%X", $amapInfo->{baseAddr});
                            my $mask = hex(sprintf("0x%X", $amapInfo->{mask}));
                            my $range = sprintf("0x%x", ((($mask)&($mask-1))^$mask));
                            if ($base==0 && $mask==0) {
                              $range = sprintf("0x%x", (1<<(int($apbIeaInfo{$iea}->{addrW}))));
                            }
                            my $rangeMask = (1 << (int($apbIeaInfo{$iea}->{addrW}))) - 1;
                            my $maxInterleavedAddr = ~($mask-hex($base)) & $rangeMask;
                            my $interleavedBase = hex($base);
                            my $interleaved = 0;
                            while (($interleavedBase < $maxInterleavedAddr)){
                              if(($interleavedBase & $mask) == hex($base)){
                                if($interleavedBase != hex($base)){
                                  $interleaved++;
                                  last;
                                }
                              }
                              $interleavedBase = $interleavedBase + hex($range);
                            }                              
                            $tgtStartAddr = '64\'h'.sprintf("%x", hex($base));
                            $tgtEndAddr = $interleaved ? '64\'h'.sprintf("%x", $maxInterleavedAddr) : '64\'h'.sprintf("%x", hex($base) + hex($range) - 1);
                             
                            if($mappedRegionStr eq "") {
                              $mappedRegionStr = "[$tgtStartAddr:$tgtEndAddr]";
                            }
                            else {
                              $mappedRegionStr .= ", [$tgtStartAddr:$tgtEndAddr]";
                            }
                          }

                          print OUTFILE "\t\t\t\t`uvm_rand_send_with(burst, {\n";
                          if ($apb_direction ne 'rw') {
                            print OUTFILE "\t\t\tDirection == " . apb_direction($apb_direction) . "; \n";
                          }
                            #STG doesn't set address width in configuration and even if we add it to the configuration VIP randomization doesn't follow it.
                            #If a certain address is required not to be inside some range e.g. 64'h0:64'h1FFF and the address width is smaller than 64 e.g. 13 bits, 
                            #Then the randomized FirstAddr can have a value 64'h41000 and actual driven address would be in the range which is not allowed.
                            #We are adding following constraint to avoid this, ideally this should be a VIP constraint (the soft constraint they have doesn't impact this)
                            print OUTFILE "\t\t\t\tAddr inside {[0:$max_addr]};  \n";
                          print OUTFILE "\t\t\t\t\t!(Addr inside {$mappedRegionStr});  \n";
                          print OUTFILE "\t\t\t\t}) \n";
                      }
                      else {
                          if ($inclDbgReg) {
                            my $dbgBaseAddr = sprintf("64\'h%x", $dbgBase);
                            my $dbgEndAddr = sprintf("64\'h%x", $dbgBase+4095);
                            print OUTFILE "   \tend else if (in_port_name == \"$iea\" && start_address == $dbgBaseAddr) begin \n";
                            print OUTFILE "   \t\tvoid'(burst.randomize() with { \n";
                            #STG doesn't set address width in configuration and even if we add it to the configuration VIP randomization doesn't follow it.
                            #If a certain address is required not to be inside some range e.g. 64'h0:64'h1FFF and the address width is smaller than 64 e.g. 13 bits, 
                            #Then the randomized FirstAddr can have a value 64'h41000 and actual driven address would be in the range which is not allowed.
                            #We are adding following constraint to avoid this, ideally this should be a VIP constraint (the soft constraint they have doesn't impact this)
                            print OUTFILE "\t\t\t\tAddr inside {[0:$max_addr]};  \n";
                            print OUTFILE "\t\t\t\t!(Addr inside {[$dbgBaseAddr:$dbgEndAddr]});  \n";
                            if ($apb_direction ne 'rw') {
                                print OUTFILE "\t\t\tDirection == " . apb_direction($apb_direction) . "; \n";
                            }
                            print OUTFILE "\t\t\t}); \n";
                            print OUTFILE "  \t`uvm_send(burst) \n";
                          }
                          if ($apb_direction ne 'rw') {
                            print OUTFILE "   \t\tend else if (in_port_name == \"$iea\") begin \n";
                            print OUTFILE "\t\t\t\t`uvm_rand_send_with(burst, {\n";
                            print OUTFILE "\t\t\tDirection == " . apb_direction($apb_direction) . "; \n";
                            print OUTFILE "\t\t\t\t}) \n";
                          }
                      }
                    }
                    print OUTFILE "  \tend else begin \n";
                    print OUTFILE "  \t\tsuper.do_item(); // default behaviour for all other cases \n";
                    print OUTFILE "  \tend \n";
                    print OUTFILE "endtask \n";
                    print OUTFILE "\n";
                    print OUTFILE "endclass : cdn_apb_master_single_trans_seq_user \n";
                    print OUTFILE "\n";
                    print OUTFILE "function __register_apb_seq(); \n";
                    print OUTFILE
"\tcdn_apb_master_single_trans_seq::type_id::set_type_override(cdn_apb_master_single_trans_seq_user::get_type()); \n";
                    print OUTFILE "\treturn 1; \n";
                    print OUTFILE "endfunction \n";
                    print OUTFILE "bit called_register_apb_seq_override = __register_apb_seq(); \n";
                }

            }
            
            #Avoid accesses to Debug Registers
            if ((($line =~ /\/\/ Factory overrides registration/) && $inclDbgReg)) {
                 $override_routing_model = <<"END_ADD";
    class usr_dut_${topMod}_env_routing_model extends dut_${topMod}_env_routing_model;
   
        `uvm_component_utils(usr_dut_${topMod}_env_routing_model)
        function new (string name = "usr_dut_${topMod}_env_routing_model", uvm_component parent=null);
            super.new(name, parent);
        endfunction
   
   
        virtual function void get_target_segments(
                           cdn_stg_sequence_routing_mechanism_t routing_mechanism,
                           cdn_stg_routing_model_port port,
                           ref cdn_stg_routing_model_memory_segment segments[\$],
                           input bit only_external_dataroutes = 1);
            super.get_target_segments(routing_mechanism, port, segments, only_external_dataroutes);  
            for (int i=segments.size()-1; i>=0; i--) begin
                if (segments[i].start_addr == $dbgBaseAddr) begin
                    segments.delete(i);
                end
        
            end
        endfunction                

    endclass

    function __register_routing_model();
        dut_${topMod}_env_routing_model::type_id::set_type_override(usr_dut_${topMod}_env_routing_model::get_type());
        return 1;
    endfunction

    bit called_register_routing_model_override = __register_routing_model();

END_ADD
                print OUTFILE $override_routing_model;
           }

           if($in_usr_axi_dwn_sizing || $apb_add_rw_logic || $in_usr_ahb_dwn_sizing) {
                #print OUTFILE "$in_usr_axi_dwn_sizing_addition";
            } else {
                print OUTFILE "$line";
            }
            print OUTFILE "$post_addition";
            $apb_add_rw_logic = 0;

        }
        close(INFILE);
        close(OUTFILE);
        system("mv tmp $usrtb");
    }
    else {
        system("rm -rf usr/usr_axi_uvm_event_callback.sv");
        system("rm -rf ${testbench}/usr/usr_axi_uvm_event_callback.sv");
    }
}
#Issue: The parsing is very crude and would fail if STG changes something (quite likely with the version update)
sub update_usr_tb_err_per_pkt {
    my $perDataRstatus_present = ($perDataRstatus == 1);
    if ($perDataRstatus_present) {
        my $usrtb = "${testbench}/usr/dut_${topMod}_usr_tb.sv";
        open(INFILE,  "<$usrtb");
        open(OUTFILE, ">tmp");

        my $in_usr_axi_tx         = 0;
        my $in_usr_apb_tx         = 0;
        my $set_slave_callback    = 0;
        my $in_usr_axi_dwn_sizing = 0;
        foreach my $line (<INFILE>) {
            my $pre_addition  = '';
            my $post_addition = '';
            if ($line =~ /class axiTransactionUsr extends cdnStg_axiTransaction/) {
                $in_usr_axi_tx = 1;
            }
            if ($line =~ /endfunction : new/ && $in_usr_axi_tx) {
                 $pre_addition = <<"END_ADD";
                   if (\$test\$plusargs("axi_err_check")) begin //{
                     this.default_resp_is_okay_exokay.constraint_mode(0);
                   end //}   
END_ADD
                $in_usr_axi_tx = 0;
            }
            if ($line =~ /class apbTransactionUsr extends cdnStg_apbTransaction/) {
                $in_usr_apb_tx = 1;
            }
            if ($line =~ /endfunction : new/ && $in_usr_apb_tx) {
                 $pre_addition = <<"END_ADD";
                 if (\$test\$plusargs("apb_err_check")) begin //{
                  this.usr_slave_resp_c.constraint_mode(0);
                 end //}   
END_ADD
                $in_usr_apb_tx = 0;
            }
            print OUTFILE "$pre_addition";
            print OUTFILE "$line";
            print OUTFILE "$post_addition";

        }
        close(INFILE);
        close(OUTFILE);
        system("mv tmp $usrtb");
    }
}

sub update_tb_ahb_slave_resp_and_wait_states {
 
  # Update User TB
  my $dutusrtb = "${testbench}/usr/dut_${topMod}_usr_tb.sv";

  open(INFILE, "<$dutusrtb");
  open(OUTFILE, ">tmp");

  my $in_target_fn_a = 0;
  my $in_target_fn_b = 0;
  my $in_target_fn_c = 0;

  foreach my $line (<INFILE>) {
  
    if($line =~ /function void configure_ahb_master\(cdnAhbUvmAgent agent\)/) {
      $in_target_fn_a = 1;
    }
    
    if($line =~ /function void configure_ahb_slave\(cdnAhbUvmAgent agent\)/) {
      $in_target_fn_b = 1;
    }
    
    if($line =~ /function __register_tb_type_overrides\(\)/) {
      $in_target_fn_c = 1;
    }
      
    
    if ($line =~ /end/ && $in_target_fn_a) {
  
      # Enable Callback
      print OUTFILE "        void'(agent.inst.setCallback(DENALI_CDN_AHB_CB_BeforeSendBurst));\n";
      print OUTFILE "$line";

      $in_target_fn_a = 0;
    } elsif ($line =~ /end/ && $in_target_fn_b) {
  
      # Enable Callback
      print OUTFILE "        agent.regInst.writeReg(DENALI_CDN_AHB_REG_randomHrDataHrUser, 'h2);\n";
      print OUTFILE "        agent.regInst.writeReg(DENALI_CDN_AHB_REG_RandomBuser, 'h1);\n";
      print OUTFILE "        void'(agent.inst.setCallback(DENALI_CDN_AHB_CB_BeforeSendTransactionResponse));\n";
      print OUTFILE "$line";

      $in_target_fn_b = 0;
    } elsif ($line =~ /return 1;/ && $in_target_fn_c && !$axi4p) {
      
      # Override UVM Monitor
      print OUTFILE "   cdnAhbUvmMonitor::type_id::set_type_override(dut_${topMod}_usr_ahb_callback_ctrl::get_type());\n";
      print OUTFILE "$line";

      $in_target_fn_c = 0;
    } else {
      print OUTFILE "$line";
    }
  }

  close(INFILE);
  close(OUTFILE);
  system("mv tmp $dutusrtb");


  # Add custom callback code
  my $dutusrcb = "${testbench}/usr/dut_${topMod}_usr_ahb_callback_ctrl.sv";

  open(INFILE, "<$dutusrcb");
  open(OUTFILE, ">tmp");
  
  my $usr_cb_custom = <<'CUSTOM_CB_CODE';
   
    int rand_value;
    int rand_threshold;
    int range;
    int waitState;
 
    // Randomize transactions response between OKAY and ERROR
    if ($test$plusargs("ahb_err_check")) begin 
 
      foreach (trans.TransfersResponses[j]) begin 
        rand_value = $urandom_range(10,0);
        rand_threshold = 8;  // Control as needed
        
        if (rand_value > rand_threshold) 
          trans.TransfersResponses[j] = DENALI_CDN_AHB_RESPONSEKIND_ERROR;
        else trans.TransfersResponses[j] = DENALI_CDN_AHB_RESPONSEKIND_OKAY;
      end
    
    end
   
    // Add Random Wait States 
    if ($test$plusargs("ahb_slv_wait_state_check")) begin
      for (int i=0; i< trans.TransfersResponsesDelay.size(); i++) begin
        range = $urandom_range(100,0);
        if (range < 30) begin
           waitState = 0;
        end else if (range < 70) begin
           waitState = $urandom_range(10,0);
        end else if (range < 90) begin
           waitState = $urandom_range(100,11);
        end else if (range < 95) begin
           waitState = $urandom_range(600,101);
        end else begin
           waitState = $urandom_range(1024,601);
        end
 
        trans.TransfersResponsesDelay [i] = waitState;
      end
    end

    void'(trans.transSet());
     
CUSTOM_CB_CODE

  my $usr_cb_insert_busy_custom = <<'CUSTOM_CB_INSERT_BUSY_CODE';
   
    int range;
    int busyTransfer;
 
    // Add Random Busy Transfers 
    if ($test$plusargs("ahb_master_busy_transfer_check")) begin
      for (int i=0; i< trans.TransfersBusyDelay.size(); i++) begin
        range = $urandom_range(100,0);
        if (range < 30) begin
           busyTransfer = 0;
        end else if (range < 70) begin
           busyTransfer = $urandom_range(6,0);
        end else if (range < 90) begin
           busyTransfer = $urandom_range(10,7);
        end else 
           busyTransfer = $urandom_range(16,8);
 
        trans.TransfersBusyDelay[i] = busyTransfer;
      end
    end

    void'(trans.transSet());
     
CUSTOM_CB_INSERT_BUSY_CODE

  foreach my $line (<INFILE>) {

    if($line =~ /virtual function void BeforeSendTransactionResponseCbF\(denaliCdn_ahbTransaction trans\)/) {
      print OUTFILE "$line";
      print OUTFILE $usr_cb_custom;
    } elsif($line =~ /virtual function void BeforeSendBurstCbF\(denaliCdn_ahbTransaction trans\)/) {
      print OUTFILE "$line";
      print OUTFILE $usr_cb_insert_busy_custom;
    } else {
      print OUTFILE "$line";
    }
  }

  close(INFILE);
  close(OUTFILE);
  system("mv tmp $dutusrcb");

}

sub update_tb_axi_ipc_tests {
  # Update axi max bandwidth ingress seq to override req IDs
  my $ipc_axi_traffic = "${testbench}/tests/ipc_tests/ipc_traffic/dut_${topMod}_tb_ipc_traffic_axi.sv";
  my $axi_req_id_control = <<'AXI_REQ_ID_OVERRIDE_CODE';
   function post_randomize();
        int rd_id, wr_id, max_rd_id, max_wr_id;
        rd_id = max_bandwidth_test::rd_count.count;
        wr_id = max_bandwidth_test::wr_count.count;
        max_rd_id = (2**ArIdLength)-1;
        max_wr_id = (2**AwIdLength)-1;
        if(Direction == DENALI_CDN_AXI_DIRECTION_WRITE) begin
            if(wr_id>max_wr_id) begin
                max_bandwidth_test::wr_count.count=max_bandwidth_test::wr_count.lower_bound;  
                wr_id=max_bandwidth_test::wr_count.lower_bound;
            end
            IdTag = wr_id;
            max_bandwidth_test::wr_count.update_count();
        end
        if (Direction == DENALI_CDN_AXI_DIRECTION_READ) begin
            if(rd_id>max_rd_id) begin
                max_bandwidth_test::rd_count.count=max_bandwidth_test::rd_count.lower_bound; 
                rd_id=max_bandwidth_test::rd_count.lower_bound;
            end
            IdTag = rd_id;
            max_bandwidth_test::rd_count.update_count();
        end
   endfunction: post_randomize
     
AXI_REQ_ID_OVERRIDE_CODE

  open(INFILE, "<$ipc_axi_traffic");
  open(OUTFILE, ">tmp");

  foreach my $line (<INFILE>) {
  
    if($line =~ /endclass : cdn_ipc_axi_max_bandwidth_ingress_burst/) {
        print OUTFILE $axi_req_id_control;
    }
      print OUTFILE "$line";
   }
  close(INFILE);
  close(OUTFILE);
  system("mv tmp $ipc_axi_traffic");

  my $max_bw_test = "${testbench}/tests/ipc_tests/max_bandwidth_test.sv";

  my $eof_max_bw_vseq=0;
  my $sof_max_bw_test=0;
  my $sof_max_bw_test_new=0;
  my $eof_max_bw_set_ipc_rw=0;
  my $axi_req_id_control = <<'AXI_REQ_COUNTER_CLASS';
        
class transaction_counter extends uvm_object;
    int count, lower_bound, upper_bound;
    `uvm_object_utils_begin(transaction_counter)
     `uvm_field_int(count, UVM_DEFAULT)
     `uvm_field_int(lower_bound, UVM_DEFAULT)
     `uvm_field_int(upper_bound, UVM_DEFAULT)
    `uvm_object_utils_end

    function new (string name = "transaction_counter", int low=0, int high=1);
      super.new(name);
      count=low;
      lower_bound=low;
      upper_bound=high;
    endfunction : new

    function void update_count();
       count++;
       if(count>upper_bound) count=lower_bound; //Circle back the count to first value
    endfunction : update_count

endclass

AXI_REQ_COUNTER_CLASS

  my $get_id_control_plusargs = <<'ACCEPT_ID_CONTROL_PLUSARGS';

   static int id_controls[6]; //index0 holds lower bound(default 0), index 1 holds upper bound and index 2 tells if index 1 holds valid value for read req(if index2=0, default max value for RD to be used). Index 3-5 hold similar info for writes (if index5=0, default max value for WR to be used). If no special range for WR provided, use same range provided for reads.
   static function int get_stg_ipc_id_controls(output int controls[6]);
      controls = id_controls;
      return 1;
   endfunction : get_stg_ipc_id_controls 

   function void set_stg_ipc_id_controls();
      string str;
      if (!$value$plusargs("STG_IPC_AXI_RD_ID_RANGE_LOW=%0d", id_controls[0])) begin
            id_controls[0]=0; //Default lower bound for read ids is zero
      end
      if (!$value$plusargs("STG_IPC_AXI_WR_ID_RANGE_LOW=%0d", id_controls[3])) begin
            id_controls[3]=0; //Default lower bound for write ids is zero

      end
      if ($value$plusargs("STG_IPC_AXI_RD_ID_RANGE_HIGH=%0d", id_controls[1])) begin
            id_controls[2]=1;//Provided upper bound in id_controls[1] to be used for reads
      end else begin
            id_controls[2]=0;//Upper bound is not provided. Use max ID supported for reads
      end
      if ($value$plusargs("STG_IPC_AXI_WR_ID_RANGE_HIGH=%0d", id_controls[4])) begin
            id_controls[5] = 1; //Provided upper bound in id_controls[4] to be used for writes
      end else begin
            id_controls[5] = 0; //Upper bound is not provided. Use max ID supported for writes
      end
   endfunction : set_stg_ipc_id_controls

ACCEPT_ID_CONTROL_PLUSARGS

  my $process_id_controls = <<'ACCEPT_AXI_ID_CONTROLS';

      set_stg_ipc_id_controls();
      get_stg_ipc_id_controls(id_controls);
      rd_id_range_low = id_controls[0];
      wr_id_range_low = id_controls[3];
      rd_id_range_high = id_controls[2] ? id_controls[1] : 512; //maxReadIdTag will be enforced by transaction object. Specified upper limit as placeholder here.
      rd_count = new("rd_count",rd_id_range_low,rd_id_range_high);
      wr_id_range_high = id_controls[5] ? id_controls[4] : 512; //maxWriteIdTag will be enforced by transaction object. Specified upper limit as placeholder here.
      wr_count = new("wr_count",wr_id_range_low,wr_id_range_high);

ACCEPT_AXI_ID_CONTROLS

  open(INFILE, "<$max_bw_test");
  open(OUTFILE, ">tmp");

  my $skip_lines=0;
  foreach my $line (<INFILE>) {
    if($skip_lines>0){
        $skip_lines --;
        next;
    }
  
    if($line =~ /endclass : max_bandwidth_vseq_test/) {
        $eof_max_bw_vseq=1;
    }
    if($line =~ /class max_bandwidth_test extends/) {
        $sof_max_bw_test=1;
    }
    if($line =~/function new\(string name\=\"max_bandwidth_test\"/){
        $sof_max_bw_test_new=1;
    }
    if($line =~ /endfunction : set_stg_ipc_readwrite/){
        $eof_max_bw_set_ipc_rw=1;
    }              
    print OUTFILE "$line";
    if($eof_max_bw_vseq==1){
        print OUTFILE $axi_req_id_control;
        $eof_max_bw_vseq=0;
    }
    if($sof_max_bw_test==1){
        print OUTFILE "   static transaction_counter rd_count, wr_count;";
        $sof_max_bw_test=0;
    }
    if($sof_max_bw_test_new==1){
        print OUTFILE "      int rd_id_range_low, rd_id_range_high, wr_id_range_low, wr_id_range_high, id_controls[6];\n";
        print OUTFILE "      super.new(name,parent);\n";
        print OUTFILE "      set_stg_ipc_length();\n";
        print OUTFILE "      set_stg_ipc_readwrite();\n";
        #skip above 3 lines in parsing loop. Doing this as there is no unique code to regex and insert own code here.
        $skip_lines=3;
        print OUTFILE $process_id_controls;
        $sof_max_bw_test_new=0;
    }
    if($eof_max_bw_set_ipc_rw==1){
        print OUTFILE $get_id_control_plusargs;
        $eof_max_bw_set_ipc_rw=0;
    }
   }
  close(INFILE);
  close(OUTFILE);
  system("mv tmp $max_bw_test");
}

sub slave_id_update_workaround {
    my $filename = shift;
    $filename = $testbench."/".$filename;
    open(INFILE, "<$filename");
    open(OUTFILE, ">tmp"); 
    foreach my $line (<INFILE>) {
        if($line =~ /var uvm_sequencer_base base_seqr/) {
            print OUTFILE "      string ipc_egress;";
        }
        if($line =~ /endtask \/\/configure_tb/){
            print OUTFILE "      if (!\$value\$plusargs(\"STG_IPC_EGRESS=%s\", ipc_egress)) begin";
            print OUTFILE "         ipc_egress = \"tgt0\";";
            print OUTFILE "      end";
            print OUTFILE "      slave_id = routing_model.get_port_id_by_name(ipc_egress);";
        }
        print OUTFILE $line;
    }
    close(INFILE);
    close(OUTFILE);
    system("mv tmp $filename");
}

sub gen_vf {
    my $axi4 = ($axi4IeaCnt > 0 || $axi4TeaCnt > 0 || $axi4p);
    my $apb  = ($apbIeaCnt > 0  || $apbTeaCnt > 0);
    my $ahb  = ($ahbIeaCnt > 0  || $ahbTeaCnt > 0);
    
    my $vf1 = "";
    my $include_llk = ($axi4p == 0);
    my @memories ;
    if (-e "${cfg_dir}/rtl/blocks.f") {
        open(BLOCKS_F, "<${cfg_dir}/rtl/blocks.f") || die "Couldn't open file ${cfg_dir}/rtl/blocks.f";
        foreach (<BLOCKS_F>) {
            #'..' in blocks.f would indicate presence of wrapper module, llk assertions don't work with this flow at the moment. 
            #This is very hacky, ideally we should create separate bind files for each domain build, which would lated be combined into ${testbench}/${testbench}.vf
            $include_llk = 0 if ($_ =~ /\.\./); 
            $vf1 .= "${cfg_dir}/rtl/".$_;
        }
    }
    else {
    if (-d "${cfg_dir}/rtl/memories") {
        opendir my $dir, "${cfg_dir}/rtl/memories" or die "Cannot open directory: $!";
        my @memories = grep { $_ =~ /Ram_.*\.sv/ } readdir $dir;
        closedir $dir;
        if (@memories) {
            $vf1 .= "${cfg_dir}/rtl/memories/mem_defines.svh\n";
            foreach $mem (@memories) {
                $vf1 .= "${cfg_dir}/rtl/memories/${mem}\n";
            }
        }
    }
    $vf1 .= "${cfg_dir}/rtl/primitives/noc_primitives.v\n";
    $vf1 .= "${cfg_dir}/rtl/noc/${topMod}.sv\n";
    }
    open(DUT_VF, ">${cfg_dir}/rtl/dut.vf") || die "Couldn't open file ${cfg_dir}/rtl/dut.vf";
    print DUT_VF "$vf1";
    close(DUT_VF) || die "Couldn't open file ${cfg_dir}/rtl/dut.vf";

    my $vf   = "";
    $vf .= "-incdir ${DENALI}/ddvapi/sv\n";
    $vf .= "${DENALI}/ddvapi/sv/denaliMem.sv\n";
    $vf .= "${DENALI}/ddvapi/sv/denaliSvd.sv\n";
    if ($axi4) {
        $vf .= "${DENALI}/ddvapi/sv/denaliCdn_axi.sv \n";
    }
    if ($apb) {
        $vf .= "${DENALI}/ddvapi/sv/denaliCdn_apb.sv \n";
    }
    if ($ahb) {
        $vf .= "${DENALI}/ddvapi/sv/denaliCdn_ahb.sv \n";
    }
    $vf .= "-incdir ${DENALI}/ddvapi/sv/uvm/svd\n";
    $vf .= "${DENALI}/ddvapi/sv/uvm/svd/cdnSvdUvmTop.sv\n";
    if ($axi4) {
        $vf .= "-incdir ${DENALI}/ddvapi/sv/uvm/cdn_axi\n";
        $vf .= "${DENALI}/ddvapi/sv/uvm/cdn_axi/cdnAxiUvmTop.sv\n";
    }
    if ($apb) {
        $vf .= "-incdir ${DENALI}/ddvapi/sv/uvm/cdn_apb\n";
        $vf .= "${DENALI}/ddvapi/sv/uvm/cdn_apb/cdnApbUvmTop.sv\n";
    }
    if ($ahb) {
        $vf .= "-incdir ${DENALI}/ddvapi/sv/uvm/cdn_ahb\n";
        $vf .= "${DENALI}/ddvapi/sv/uvm/cdn_ahb/cdnAhbUvmTop.sv\n";
    }


    $vf .= "-f ${cfg_dir}/rtl/dut.vf\n";
    if ($include_llk) {
        foreach (@vf_files) {
            $vf .= "$_\n";
        }
    }

    open(STG_VF, ">${cfg_dir}/${testbench}/${testbench}.vf") || die "Couldn't open file ${cfg_dir}/${testbench}/${testbench}.vf";
    print STG_VF "$vf";
    close(STG_VF) || die "Couldn't open file ${cfg_dir}/${testbench}/${testbench}.vf";

}

sub dut_top {
    my $duttop = "${testbench}/dut_${topMod}.sv";
    open(INFILE,  "<$duttop");
    open(OUTFILE, ">tmp");

    if ($axi4p) {
        my $insert_clk_rst = 0;
        my $start          = 0;
        my $dut_rst        = 0;
        foreach my $line (<INFILE>) {
            my $pre_addition     = '';
            my $assign_addition  = '';
            my $ratio_addition   = '';
            my $rst_addition     = '';
            my $dut_rst_addition = '';
            if ($line =~ /module dut_${topMod}/) { $start = 1; }
            if (($line =~ /initial begin/) && $start) {
                $pre_addition = "   wire [$ridxW-1:0] ridx;\n";
                $pre_addition .= "   wire [$ridxW-1:0] aridx_out;\n";
                $pre_addition .= "   wire [($ridW+$ridxW)-1:0] arid_dst;\n";
                $pre_addition .= "   wire [$ridW-1:0] dst_rid;\n";
                $pre_addition .= "   wire [$widxW-1:0] bidx;\n";
                $pre_addition .= "   wire [$widxW-1:0] awidx_out;\n";
                $pre_addition .= "   wire [($widW+$widxW)-1:0] awid_dst;\n";
                $pre_addition .= "   wire [$widW-1:0] dst_bid;\n\n";
                $pre_addition .= "   initial begin\n";
                $start = 0;
                print OUTFILE "$pre_addition";
            }
            elsif (($line =~ /${topMod} i_${topMod}/)) {
                if ($rreorder) {
                    $assign_addition = "   assign arid_dst[($ridxW+$ridW)-1:$ridW] = aridx_out;\n";
                    $assign_addition .= "   assign arid_dst[$ridW-1:0] = ARID__dst_arid;\n";
                    $assign_addition .= "   assign dst_rid = RID__dst_rid;\n";
                    $assign_addition .= "   assign ridx = RID__dst_rid[($ridxW+$ridW)-1:$ridW];\n\n";
                }
                if ($wreorder) {
                    $assign_addition .= "   assign awid_dst[($widxW+$widW)-1:$widW] = awidx_out;\n";
                    $assign_addition .= "   assign awid_dst[$widW-1:0] = AWID__dst_awid;\n";
                    $assign_addition .= "   assign dst_bid = BID__dst_bid;\n";
                    $assign_addition .= "   assign bidx = BID__dst_bid[($widxW+$widW)-1:$widW];\n\n\n";
                }
                $assign_addition .= "   ${topMod} i_${topMod}(\n";
                if ($rreorder) {
                    $assign_addition .= "      .aridx(aridx_out),\n";
                    $assign_addition .= "      .ridx(ridx),\n";
                }
                if ($wreorder) {
                    $assign_addition .= "      .awidx(awidx_out),\n";
                    $assign_addition .= "      .bidx(bidx),\n";
                }
                print OUTFILE "$assign_addition";
            }
            elsif ($line =~ /\.dst_bid\(BID__dst_bid\)/ && $wreorder) {
                print OUTFILE "      .dst_bid(dst_bid),\n";
            }
            elsif ($line =~ /\.dst_rid\(RID__dst_rid\)/ && $rreorder) {
                print OUTFILE "      .dst_rid(dst_rid),\n";
            }
            elsif ($line =~ /\.awid\(AWID__dst_awid\)/ && $wreorder) {
                print OUTFILE "      .awid(awid_dst),\n";
            }
            elsif ($line =~ /\.arid\(ARID__dst_arid\)/ && $rreorder) {
                print OUTFILE "      .arid(arid_dst),\n";
            }
            else {
                print OUTFILE "$line";
            }
        }
    }
    else {
        foreach my $line (<INFILE>) {
            my $assign_addition = '';
            my $pre_addition = '';
            if (($line =~ /${topMod} i_${topMod}/)) {
                $pre_addition .= "  initial begin\n";
                $pre_addition .= "      if (\$test\$plusargs(\"randomize_isolation_links\")) begin\n";
                foreach my $link (@isolation_links) {
                    $pre_addition .= "          if (\$urandom()%2)\n";
                    $pre_addition .= "              force i_${topMod}.${link} = 1'b1;\n";
                    $pre_addition .= "          else\n";
                    $pre_addition .= "              force i_${topMod}.${link} = 1'b0;\n";
                    $pre_addition .= "\n";
                }
                $pre_addition .= "      end\n";
                $pre_addition .= "  end\n";
                $pre_addition .= "\n\n";
                $assign_addition .= "   ${topMod} i_${topMod}(\n";
                foreach my $link (@isolation_links) {
                    $assign_addition .= "      .$link(1\'b1),\n";
                }
                print OUTFILE "$pre_addition";
                print OUTFILE "$assign_addition";
            }
            else {
                print OUTFILE "$line";
            }
        }
    }
    close(INFILE);
    close(OUTFILE);
    system("mv tmp $duttop");
}

my $prot_present; 
sub dut_usr_env {
    my @ieaProts;
    foreach my $iea (keys %ieaInfo) {
        if ($ieaInfo{$iea}->{prot}) {
            push(@ieaProts, $iea);
        }
    }
    my @teaProts;
    foreach my $tea (keys %teaInfo) {
        if ($teaInfo{$tea}->{prot}) {
            push(@teaProts, $tea);
        }
    }

    $prot_present = ((scalar(@ieaProts) > 0) && (scalar(@teaProts) > 0));

    if ($prot_present) {
        my $dutusrenv = "${testbench}/usr/dut_${topMod}_usr_env.sv";
        open(INFILE,  "<$dutusrenv");
        open(OUTFILE, ">tmp");

        my $add = 0;
        foreach my $line (<INFILE>) {
            my $post_addition = '';
            if (($line =~ /trans.CompoundItemIdOut = `IGNORE_ID;/)) {
                $add = 1;
            }
            if (($line =~ /endfunction/) && $add) {
                $add = 0;

                print OUTFILE "$line";
                print OUTFILE "\tvirtual function void UserCompoundItemDone(ref denaliSvdTransaction InputTransaction, ref \n";
                print OUTFILE "\t\tdenaliSvdTransaction OutputTransactions[\$], ref denaliSvdTransaction SnoopTransactions[\$]); \n";
                if ($axi4IeaCnt > 0) {
                    print OUTFILE "\t\tdenaliCdn_axiTransaction axiInputTrans;\n";
                }
                if ($axi4TeaCnt > 0) {
                    print OUTFILE "\t\tdenaliCdn_axiTransaction axiOutputTrans;\n";
                }
                if ($apbIeaCnt > 0) {
                    print OUTFILE "\t\tdenaliCdn_apbTransaction apbInputTrans;\n";
                }
                if ($apbTeaCnt > 0) {
                    print OUTFILE "\t\tdenaliCdn_apbTransaction apbOutputTrans;\n";
                }
                if ($ahbIeaCnt > 0) {
                    print OUTFILE "\t\tdenaliCdn_ahbTransaction ahbInputTrans;\n";
                }
                if ($ahbTeaCnt > 0) {
                    print OUTFILE "\t\tdenaliCdn_ahbTransaction ahbOutputTrans;\n";
                }

                my $post_addition = '';
                $post_addition = <<"END_ADD";
\t\tbit check;
\t\tcheck = 0;
END_ADD
                print OUTFILE "$post_addition";

                print OUTFILE "//If Prot is disabled in Initiaor or Target- Disable Check\n";
                print OUTFILE "\t\tif (OutputTransactions.size() > 0) begin \n";
                my $cnt          = 1;
                my $ieaProtCheck = join(' || ', map(("InputTransaction.PortName == \"$_\"", @ieaProts)));
                my $teaProtCheck = join(' || ', map(("OutputTransactions[0].PortName == \"$_\"", @teaProts)));

                print OUTFILE "\t\t\tif \(\n";
                print OUTFILE "\t\t\t\t(1'b0 || $ieaProtCheck)\n";
                print OUTFILE "\t\t\t\t&& (1'b0 || $teaProtCheck)\n";
                print OUTFILE "\t\t\t) begin\n";
                print OUTFILE "\t\t\t\tcheck = 1'b1;\n";
                print OUTFILE "\t\t\tend\n";

                print OUTFILE "\t\tend\n";

                print OUTFILE "\t\tif (OutputTransactions.size() > 0) begin\n";
                print OUTFILE "\t\t\tif(check) begin\n";
                if ($apbTeaCnt > 0) {
                    print OUTFILE "\t\t\t\tif(OutputTransactions\[0\].Protocol == DENALI_SVD_PROTOCOL_APB) begin\n";
                    if ($apbIeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             \/\/ The following code casts generic SVD transactions to AXI protocol transactions...
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_APB) begin
                               \$cast(apbInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(apbOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (apbInputTrans.Privileged != apbOutputTrans.Privileged) begin
                                `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged /target Privileged mismatch!\"); 
                               end 
                               if (apbInputTrans.Secure != apbOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure /target Secure mismatch!\");
                               end
                               if (apbInputTrans.DataInstr != apbOutputTrans.DataInstr) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr /target DataInstr mismatch!\");
                               end
                             end 
END_ADD
                        print OUTFILE "$post_addition";
                    }
                    if ($axi4IeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_AXI) begin 
                               \$cast(axiInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(apbOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (axiInputTrans.Privileged != apbOutputTrans.Privileged) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                               end
                               if (axiInputTrans.Secure != apbOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                               end
                               if (axiInputTrans.DataInstr != apbOutputTrans.DataInstr) begin
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                               end
                              end 

END_ADD
                        print OUTFILE "$post_addition";
                    }
                    if ($ahbIeaCnt > 0 && 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_AHB) begin 
                               \$cast(ahbInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(apbOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (ahbInputTrans.Privileged != apbOutputTrans.Privileged) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                               end
                               if (ahbInputTrans.Secure != apbOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                               end
                               if (ahbInputTrans.DataInstr != apbOutputTrans.DataInstr) begin
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                               end
                              end 

END_ADD
                        print OUTFILE "$post_addition";
                    }
                    print OUTFILE "\t\t\t\tend //}\n";
                }
                if ($axi4TeaCnt > 0) {
                    print OUTFILE "\t\t\t\tif(OutputTransactions[0].Protocol == DENALI_SVD_PROTOCOL_AXI) begin //{ \n";
                    if ($apbIeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             \/\/ The following code casts generic SVD transactions to AXI protocol transactions...
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_APB) begin 
                               \$cast(apbInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(axiOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (apbInputTrans.Privileged != axiOutputTrans.Privileged) begin
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                               end
                               if (apbInputTrans.Secure != axiOutputTrans.Secure) begin
                   
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                               end
                               if (apbInputTrans.DataInstr != axiOutputTrans.DataInstr) begin
                   
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                               end
                             end 
END_ADD
                        print OUTFILE "$post_addition";
                    }
                    if ($axi4IeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                            if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_AXI) begin //{
                            \$cast(axiInputTrans, InputTransaction.protocolItem); 
                            if (OutputTransactions.size() > 0) begin //{
                               \$cast(axiOutputTrans,
                               OutputTransactions[0].protocolItem);
                            end //}
                             \/\/ ... and checks matching of User transaction fields.
                            if (axiInputTrans.Privileged != axiOutputTrans.Privileged) begin
                               `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                            end
                            if (axiInputTrans.Secure != axiOutputTrans.Secure) begin
                                `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                            end
                            if (axiInputTrans.DataInstr != axiOutputTrans.DataInstr) begin
                                `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                            end
                            end //}
END_ADD
                        print OUTFILE "$post_addition";
                    }
                    if ($ahbIeaCnt > 0 && 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_AHB) begin 
                               \$cast(ahbInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(axiOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (ahbInputTrans.Privileged != axiOutputTrans.Privileged) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                               end
                               if (ahbInputTrans.Secure != axiOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                               end
                               if (ahbInputTrans.DataInstr != axiOutputTrans.DataInstr) begin
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                               end
                              end 

END_ADD
                        print OUTFILE "$post_addition";
                    }
                    print OUTFILE "\t\t\t\tend //}\n";
                }
                if ($ahbTeaCnt > 0 && 0) {
                    print OUTFILE "\t\t\t\tif(OutputTransactions\[0\].Protocol == DENALI_SVD_PROTOCOL_AHB) begin\n";
                    if ($apbIeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             \/\/ The following code casts generic SVD transactions to AXI protocol transactions...
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_APB) begin
                               \$cast(apbInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(apbOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (apbInputTrans.Privileged != ahbOutputTrans.Privileged) begin
                                `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged /target Privileged mismatch!\"); 
                               end 
                               if (apbInputTrans.Secure != ahbOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure /target Secure mismatch!\");
                               end
                               if (apbInputTrans.DataInstr != ahbOutputTrans.DataInstr) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr /target DataInstr mismatch!\");
                               end
                             end 
END_ADD
                        print OUTFILE "$post_addition";
                    }
                    if ($axi4IeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_AXI) begin 
                               \$cast(axiInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(ahbOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (axiInputTrans.Privileged != ahbOutputTrans.Privileged) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                               end
                               if (axiInputTrans.Secure != ahbOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                               end
                               if (axiInputTrans.DataInstr != ahbOutputTrans.DataInstr) begin
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                               end
                              end 

END_ADD
                        print OUTFILE "$post_addition";
                    }
                    if ($ahbIeaCnt > 0) {
                        my $post_addition = '';
                        $post_addition = <<"END_ADD";
                             if(InputTransaction.Protocol == DENALI_SVD_PROTOCOL_AHB) begin 
                               \$cast(ahbInputTrans, InputTransaction.protocolItem);
                               if (OutputTransactions.size() > 0) begin 
                                  \$cast(ahbOutputTrans,
                                  OutputTransactions[0].protocolItem);
                               end 
                                \/\/ ... and checks matching of User transaction fields.
                               if (ahbInputTrans.Privileged != ahbOutputTrans.Privileged) begin
                                 `uvm_fatal(get_type_name(), \"SVD detected iniator Privileged \/target Privileged mismatch!\");
                               end
                               if (ahbInputTrans.Secure != ahbOutputTrans.Secure) begin
                                   `uvm_fatal(get_type_name(), \"SVD detected iniator Secure \/target Secure mismatch!\");
                               end
                               if (ahbInputTrans.DataInstr != ahbOutputTrans.DataInstr) begin
                                  `uvm_fatal(get_type_name(), \"SVD detected iniator DataInstr \/target DataInstr mismatch!\");
                               end
                              end 

END_ADD
                        print OUTFILE "$post_addition";
                    }
                    print OUTFILE "\t\t\t\tend //}\n";
                }
                print OUTFILE "\t\t\tend //Check\n";
                print OUTFILE "\t\tend // OutTransaction.size\n";
                print OUTFILE "\tendfunction\n";

                my $post_addition2 = '';

#Normally, CMO transactions such as CleanInvalid and CleanShared do not get propagated to egress interfaces, even if the egress interfaces are defined as ACE Lite. That's why the SVD expected fanout by default is empty for these transactions and that's the reason for ERR_017_UNKNOWN_MISMATCH error.
#Fixed it by manually adjusting the fanout by using SVD's UserAdjustFanout() function and add it to the *_usr_env.sv file located under ${testbench}/usr directory.
# Update Case #46686335 For ACE-Lite Initiator to ACE-Lite Target
                if ($AceLitePresent) {
                    $post_addition2 = <<"END_ADD";
//=======================================================================
virtual function bit UserAdjustFanout(denaliSvdTransaction InputTransaction,
                                      reg [63:0] Addr,
                                      ref reg [63:0] FanoutPortIds[\$],
                                      reg [63:0] FullFanoutPortIds[],
                                      ref reg[63:0] UncertainInterfacesPortIds[\$]);

       denaliCdn_axiTransaction axiInputTrans;
        
       // Cast to AXI transaction
       if(!\$cast(axiInputTrans, InputTransaction.protocolItem)) begin
      `uvm_info(get_name(),
              {"Cannot cast input ",
              InputTransaction.protocolItem.get_type_name(),
              " to AXI transaction"},UVM_HIGH)
              return 0;
       end

       // Use AXI Transaction field value to update the fanout.
	if ((axiInputTrans.ReadSnoop inside {[DENALI_CDN_AXI_READSNOOP_CleanShared:DENALI_CDN_AXI_READSNOOP_CleanInvalid]}) || (axiInputTrans.ReadSnoop == DENALI_CDN_AXI_READSNOOP_MakeInvalid)) begin
END_ADD
                    print OUTFILE "$post_addition2";
                    foreach my $name (@axi4TeaNames) {
                        print OUTFILE
"\tFanoutPortIds.push_back(portNames\[\"$name\"\]);   // You can add more egress port names as needed \n";
                    }
                    print OUTFILE "\t      return 1;\n";
                    print OUTFILE "\tend else\n";
                    print OUTFILE "\t     return 0;\n";
                    print OUTFILE "    endfunction\n";

                    my $post_addition3 = '';
                    $post_addition3 = <<"END_ADD";
   virtual function void end_of_elaboration_phase(uvm_phase phase);
      int status;

      super.end_of_elaboration_phase(phase);

      // enable callbacks
      status = setCallback(DENALI_SVD_CB_CompoundItemDone);
      status = setCallback(DENALI_SVD_CB_FanoutUpdated);
   endfunction

END_ADD

                    print OUTFILE "$post_addition3";
                }
            }
            else {
                print OUTFILE "$line";
            }
        }
        close(INFILE);
        close(OUTFILE);
        system("mv tmp $dutusrenv");
    }

    # Enabling SVD error for Exclusive Transfers with AHB
    my $dutusrenv = "${testbench}/usr/dut_${topMod}_usr_env.sv";
    open(INFILE,  "<$dutusrenv");
    open(OUTFILE, ">tmp");

    my $in_class    = 0;
    my $in_function = 0;
    foreach my $line (<INFILE>) {

        if (($line =~ /class dut_${topMod}_env_scoreboard_agent_user extends dut_${topMod}_env_scoreboard_agent/)) {
            $in_class = 1;
        }

        if (($line =~ /virtual function void end_of_elaboration_phase\(uvm_phase phase\)/) && $in_class) {
            $in_class    = 0;
            $in_function = 1;
        }

        if (($line =~ /endfunction/) && $in_function) {
            $in_function = 0;
            if ($ahbIeaCnt) {
                print OUTFILE "      inst.regWrite(DENALI_SVD_REG_AllowErrorRespGenerationByDUT, 1'b0); \n";
            }
            print OUTFILE "      inst.regWrite(DENALI_SVD_REG_MaxNumberOfInterfaceItems, 3000); \n";
            print OUTFILE "      inst.regWrite(DENALI_SVD_REG_UseCache, 0); \n";
            print OUTFILE "      if (\$test\$plusargs(\"svd_tracker\")) begin\n";
            print OUTFILE "         inst.regWrite(DENALI_SVD_REG_EnableTracker, 4'b1111); \n";
            print OUTFILE "      end\n";
            print OUTFILE "$line";
        }
        else {
            print OUTFILE "$line";
        }
    }

    close(INFILE);
    close(OUTFILE);
    system("mv tmp $dutusrenv");
}

#For Read only & Write only config - Adding UVM severity change for Initiator in base testcase. 
#All STG testcases.
##Directed Testcase is already taken care for Read only - Write only.
sub dut_base_test {

    calc_rdwr_cfg();

    if ($#constraint_rdwronly > -1) {
        my $dutbasetest = "${testbench}/tests/dut_${topMod}_tb_base_test.sv";
        open(INFILE,  "<$dutbasetest");
        open(OUTFILE, ">tmp");

        foreach my $line (<INFILE>) {
            my $post_addition = '';
            if (($line =~ /endclass/)) {
                print OUTFILE "virtual function void end_of_elaboration_phase(uvm_phase phase); \n";
                foreach my $iniName (@constraint_rdwronly) {

                    print OUTFILE
"tb.all_vips.$iniName.passive_slave.monitor.set_report_severity_id_override(UVM_FATAL,\"CDN_AXI_FATAL_ERR_VR_AXI235_WRITE_BURST_MAPPED_ADDRESS_AND_DECERR\",UVM_WARNING); \n";
                    print OUTFILE
"tb.all_vips.$iniName.passive_slave.monitor.set_report_severity_id_override(UVM_FATAL,\"CDN_AXI_FATAL_ERR_VR_AXI231_READ_TRANSFER_MAPPED_ADDRESS_AND_DECERR\",UVM_WARNING); \n";

                }
                print OUTFILE "      if(\$test\$plusargs(\"allow_illegals\")) begin\n";
                foreach my $tea (keys %axi4TeaInfo) {
                    next if $teaInfo{$tea}->{bus} ne "ACELite";
                    print OUTFILE
"tb.all_vips.$tea.passive_master.monitor.set_report_severity_id_override(UVM_FATAL,\"CDN_AXI_FATAL_ERR_VR_AXI3134_WRONG_AWDOMAIN_FOR_NON_SHAREABLE_ADDRESS_SPACE\",UVM_WARNING); \n";
                    print OUTFILE
"tb.all_vips.$tea.passive_master.monitor.set_report_severity_id_override(UVM_FATAL,\"CDN_AXI_FATAL_ERR_VR_AXI3135_WRONG_ARDOMAIN_FOR_NON_SHAREABLE_ADDRESS_SPACE\",UVM_WARNING); \n";
                    print OUTFILE
"tb.all_vips.$tea.passive_master.monitor.set_report_severity_id_override(UVM_FATAL,\"CDN_AXI_FATAL_ERR_VR_AXI3144_WRONG_AWDOMAIN_FOR_INNER_ADDRESS_SPACE\",UVM_WARNING); \n";
                    print OUTFILE
"tb.all_vips.$tea.passive_master.monitor.set_report_severity_id_override(UVM_FATAL,\"CDN_AXI_FATAL_ERR_VR_AXI3145_WRONG_ARDOMAIN_FOR_INNER_ADDRESS_SPACE\",UVM_WARNING); \n";
                }
                print OUTFILE
"tb.all_scoreboards.scoreboard.monitor.set_report_severity_id_override(UVM_ERROR,\"DENALI_SVD_ERR_050_RESPONSE_MISMATCH\",UVM_WARNING); \n";
                print OUTFILE "      end; \n";
                print OUTFILE "endfunction :end_of_elaboration_phase\n";
            }
            print OUTFILE "$line";
        }
        close(INFILE);
        close(OUTFILE);
        system("mv tmp $dutbasetest");
    }
}

sub stimulus_after_reset_control {

  my $dutbasetest = "${testbench}/env/sv/dut_${topMod}_env_vseq_lib.sv";

  if($ahbIeaCnt > 0) {
    open(INFILE, "<$dutbasetest");
    open(OUTFILE, ">tmp");

    my $stimulus_control = <<'STIMULUS_CTRL';
      fork : configure_dut_event
        config_ur_scenario_if_set("wait_for_stg_configure_dut_event", 1);		
        `uvm_info("STG_CONFIGURE_DUT_EVENT", "Waiting for STG configure DUT event", UVM_LOW)
        stg_configure_dut_event.wait_ptrigger();
        `uvm_info("STG_CONFIGURE_DUT_EVENT", "Finished waiting for STG configure DUT event", UVM_LOW)      
        config_ur_scenario_if_set("wait_for_stg_configure_dut_event", 0);

        begin
          #800ns;
          stg_configure_dut_event.trigger();
        end
      join : configure_dut_event

STIMULUS_CTRL

    my $base_test_class = "class dut_${topMod}_env_base_vseq_test"; 
    my $in_target_class = 0;
    my $stim_ctrl = 0;

    foreach my $line (<INFILE>) {
      
      if($line =~ /$base_test_class\b/) {
          $in_target_class = 1;
      }
    
      if ($line =~ /virtual task wait_configure_dut_event\(\);/ && $in_target_class) {
        print OUTFILE "$line";
        print OUTFILE $stimulus_control;
        
        $in_target_class = 0;
        $stim_ctrl = 1;
      
      } elsif ($line !~ /endtask/ && $stim_ctrl) {
      } else {
        print OUTFILE "$line";
        $stim_ctrl = 0;
      }
    }

    close(INFILE);
    close(OUTFILE);
    system("mv tmp $dutbasetest");
  }
}

sub clk_freq_control {

  my $dutbasetest = "${testbench}/env/sv/dut_${topMod}_env_vseq_lib.sv";

  open(INFILE, "<$dutbasetest");
  open(OUTFILE, ">tmp");

  my $clk_ctrl_code_a = <<CLK_CTRL_A;
      
      string clocking_info;
      string clock_pairs[\$];
      string clk_info[\$];
      int reset_clk_freq;
      real reset_init_delay;
      
      `uvm_info(get_name(), "****** CLOCK FREQUENCY CONTROL ******", UVM_NONE)
      
      fork
        begin
          if(\$value\$plusargs("reset_clk_freq=%0d", reset_clk_freq)) begin
            reset_init_delay = 10000000 / reset_clk_freq; // (10 clock cycles of clock in ps)

            while(!p_sequencer.${topRst}_vif.is_inreset())
              #1;

            while(p_sequencer.${topRst}_vif.is_inreset())
              #1;

            p_sequencer.${topRst}_vif.start_reset();
            #reset_init_delay;
		        p_sequencer.${topRst}_vif.end_reset();

          end
        end
 
        begin
          if(\$value\$plusargs("clocking_info=%s", clocking_info)) begin
            string clk_name, freq_str;
            int clock_freq;
      
            uvm_split_string(clocking_info, ",", clock_pairs);
      
            foreach (clock_pairs[i]) begin
              uvm_split_string(clock_pairs[i], ":", clk_info);
      
              if(\$sscanf(clk_info[1], "%0d", clock_freq)) begin
                string clk_vif_name = \$sformatf("%s_vif",clk_info[0]);
                 
                // All possible clock VIFs 
CLK_CTRL_A

  my $clk_ctrl_code_b = <<CLK_CTRL_B;

              end
            end
          end
        end
      join
      disable fork;
      
      `uvm_info(get_name(), "****** END OF CLOCK FREQUENCY CONTROL ******", UVM_NONE)

CLK_CTRL_B

  my $base_test_class = "class dut_${topMod}_env_base_vseq_test"; 
  my $in_target_class = 0;

  foreach my $line (<INFILE>) {
    
    if($line =~ /$base_test_class\b/) {
        $in_target_class = 1;
    }
  
    if ($line =~ /virtual task body\(\);/ && $in_target_class) {
      print OUTFILE "$line";
      print OUTFILE $clk_ctrl_code_a;

      foreach my $clk_name (@clkNames) {
         print OUTFILE "                if(clk_vif_name == \"${clk_name}_vif\")\n";
         print OUTFILE "                  p_sequencer.${clk_name}_vif.set_clock_freq_in_mhz(clock_freq);\n";
      }

      print OUTFILE $clk_ctrl_code_b;

      $in_target_class = 0;
    } else {
        print OUTFILE "$line";
    }
  }

  close(INFILE);
  close(OUTFILE);
  system("mv tmp $dutbasetest");
}


sub axi_size_dataW {
    $min_dataW = $_[0];
    my $tgt_size_dataw;

    if ($min_dataW eq 8) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_BYTE";
    }
    elsif ($min_dataW eq 16) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_HALFWORD";
    }
    elsif ($min_dataW eq 32) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_WORD";
    }
    elsif ($min_dataW eq 64) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_TWO_WORDS";
    }
    elsif ($min_dataW eq 128) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_FOUR_WORDS";
    }
    elsif ($min_dataW eq 256) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_EIGHT_WORDS";
    }
    elsif ($min_dataW eq 512) {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_SIXTEEN_WORDS";
    }
    else {
        $tgt_size_dataw = "DENALI_CDN_AXI_TRANSFERSIZE_K_BITS";
    }

    return $tgt_size_dataw;
}

##For all Initiator & Target routing, check RW config.
sub calc_rdwr_cfg {
    foreach my $iea (keys %ieaInfo) {
        my $rw_mismatch = 0;
        foreach my $tea (@{ $ieaInfo{$iea}->{targets} }) {
            if ($ieaInfo{$iea}->{rw} ne $teaInfo{$tea}->{rw}) {
                push(@constraint_rdwronly, $iea);
                $rw_mismatch = 1;
                last;
            }
        }
        if ($rw_mismatch == 0) {
            foreach my $amapEntry (@{ $ieaInfo{$iea}->{aMap} }) {
                if (($ieaInfo{$iea}->{rw} ne $amapEntry->{rw})) {
                    push(@constraint_rdwronly, $iea);
                    $rw_mismatch = 1;
                    last;
                }
            }
        }
    }
}

sub apb_direction {
    $min_rw = $_[0];

     if ($min_rw eq 'r') {
       $apbDirection = "DENALI_CDN_APB_DIRECTION_READ";
     } else {
       $apbDirection = "DENALI_CDN_APB_DIRECTION_WRITE";
     }

    return $apbDirection;
}

sub spa_commands {
    my @ipc_tests = ("max_bandwidth_test", "min_latency_test", "ot_sweep_test");
    my $length    = 8;
    my $commands  = '';
    my $spa_csv = $cfg_dir."/spa_tests.csv";
    my $csv_entry;
    my $rd_ot;
    my $wr_ot;
    open SPA_CSV, '>', $spa_csv or die "File '$spa_csv' can't be opened";
    	print SPA_CSV "############################################################################\n";
	print SPA_CSV "# This is sample csv file to generate ipc runs for the config. User can    #\n";
	print SPA_CSV "# add new lines to generate respective test run command as per requirement.#\n";
	print SPA_CSV "# Each test has different set of arguments and same are mentioned in the   #\n";
	print SPA_CSV "# intermediate comments below.we can edit this file and run gen_spa_cmds.pl#\n";
	print SPA_CSV "# script in config directory 'cfg_dir/scripts/gen_spa_cmds.pl'. Always run #\n";
    print SPA_CSV "# it from config directory. Output file 'performance_runs' in config dir.  #\n";
	print SPA_CSV "# gets updated after running the script to add new run commands to it      #\n";
	print SPA_CSV "# Script runs in the build flow to dump a sample output file.              #\n";
	print SPA_CSV "############################################################################\n";
	print SPA_CSV "\n";

    foreach my $test (@ipc_tests) {
	if($test eq 'max_bandwidth_test') { print SPA_CSV "#########".$test.",ini,tgt,ipc_rw,ipc_len,min_num_tx,max_num_tx,rd_req_id_low,rd_req_id_high,wr_req_id_low,wr_req_id_high\n"; }
    if($test eq 'min_latency_test'){ print SPA_CSV "#########".$test.",ini,tgt,ipc_rw,ipc_len,min_num_tx,max_num_tx\n"; }
	if($test eq 'ot_sweep_test'){ print SPA_CSV "##############ot_sweep_test,ini,tgt,ipc_rw,rd_ot,wr_ot,min_num_tx,max_num_tx\n";}
        foreach my $iea (keys %ieaInfo) {
            # next if ($ieaInfo{$iea}->{bus} eq "APB");
            next if ($ieaInfo{$iea}->{bus} eq "AHB" && $test eq "ot_sweep");
            foreach my $tea (@{ $ieaInfo{$iea}->{targets} }) {
                next if ($tea eq "*ID0");
                foreach $access ("READ_ONLY", "WRITE_ONLY", "READ_WRITE") {
                    next if ($access =~ /READ/  && !($ieaInfo{$iea}->{rw} =~ /r/ && $teaInfo{$tea}->{rw} =~ /r/));
                    next if ($access =~ /WRITE/ && !($ieaInfo{$iea}->{rw} =~ /w/ && $teaInfo{$tea}->{rw} =~ /w/));
                    next if ($access eq "READ_WRITE" && ($test eq "ot_sweep"));
                    # next if ($ieaInfo{$iea}->{bus} eq "AXI4" || $ieaInfo{$iea}->{bus} eq "ACELite") && ($teaInfo{$tea}->{bus} ne "AXI4" && $teaInfo{$tea}->{bus} ne "ACELite");
                    # next if ($ieaInfo{$iea}->{bus} eq "AHB" && $teaInfo{$tea}->{bus} ne "AHB");
                    my $max_length = $length;
                    if ($ieaInfo{$iea}->{bus} eq "AXI4" || $ieaInfo{$iea}->{bus} eq "ACELite") {
                        my $maxRDP = $axi4IeaInfo{$iea}->{maxRDP} // 0;
                        if (   $maxRDP > 0
                            && $length < $maxRDP
                            && (   $access =~ /READ/ && $axi4IeaInfo{$iea}->{rReorder} eq "qm"
                                || $access =~ /WRITE/ && $axi4IeaInfo{$iea}->{wReorder} eq "qm")
                          ) {
                            $max_length = $maxRDP;
                        }
                    }
		    $rd_ot = $ieaInfo{$iea}->{maxRO};
		    $wr_ot = $ieaInfo{$iea}->{maxWO};
		    if($test eq 'max_bandwidth_test'){
                $csv_entry="$test,$iea,$tea,$access,$max_length,,,,,,\n";
            }
            if($test eq 'min_latency_test'){
			    $csv_entry="$test,$iea,$tea,$access,$max_length,,\n";
		    } elsif($test eq 'ot_sweep_test'){
			    $csv_entry="$test,$iea,$tea,$access,$rd_ot,$wr_ot,,,\n";
		    }
		    print SPA_CSV $csv_entry;
                }
            }
        }
    }
    close (SPA_CSV);
    system("perl $cfg_dir/scripts/gen_spa_cmds.pl ");
}

sub setup_spa_regression {
  my $spascript = "scripts/run_spa";
  my $regress_spascript = "scripts/regress_spa";
  my $customArg = "";

  open(INFILE, "<$spascript");
  open(OUTFILE, ">$regress_spascript");

  if($ahbIeaCnt > 0) {
    $customArg = "+define+STG_CONFIGURE_DUT_EVENT";
  }

  foreach my $line (<INFILE>) {
    
    if($line =~ /system\(".\/nocrun -test max_bandwidth_test/) {
      # Add All Max Bandwidth Tests
      print OUTFILE "#$line";

      $directory = "${testbench}/tests/ipc_tests/max_bandwidth_tests/";
      if(-d $directory) {
        opendir(DIR, $directory) or die "Cannot open tests directory";
          while (my $file = readdir(DIR)) {
            next if ($file eq '.' or $file eq '..');
            print OUTFILE "system(\"./nocrun -test max_bandwidth_test -plus \\\"-f \$\{rundir\}/${testbench}/tests/ipc_tests/max_bandwidth_tests/$file $customArg\\\"\");\n";
          }
          closedir(DIR);
      }
    }
    elsif($line =~ /system\(".\/nocrun -test min_latency_test/) {
      # Add All Min Latency Tests
      print OUTFILE "#$line";
      
      $directory = "${testbench}/tests/ipc_tests/min_latency_tests/";
      if(-d $directory) {
        opendir(DIR, $directory) or die "Cannot open tests directory";
          while (my $file = readdir(DIR)) {
            next if ($file eq '.' or $file eq '..');
            print OUTFILE "system(\"./nocrun -test min_latency_test -plus \\\"-f \$\{rundir\}/${testbench}/tests/ipc_tests/min_latency_tests/$file $customArg\\\"\");\n";
          }
          closedir(DIR);
      }
    }
    elsif($line =~ /system\(".\/nocrun -test ot_sweep_test/) {
      # Add All Oustsanding Sweep Tests
      print OUTFILE "#$line";
      
      $directory = "${testbench}/tests/ipc_tests/ot_sweep_tests/";
      if(-d $directory) {
        opendir(DIR, $directory) or die "Cannot open tests directory";
          while (my $file = readdir(DIR)) {
            next if ($file eq '.' or $file eq '..');
            print OUTFILE "system(\"./nocrun -test ot_sweep_test -plus \\\"-f \$\{rundir\}/${testbench}/tests/ipc_tests/ot_sweep_tests/$file $customArg\\\"\");\n";
          }
          closedir(DIR);
      }
    }
    else {
      print OUTFILE "$line";
    }
  }

  close(INFILE);
  close(OUTFILE);
  #system("rm -Rf $spascript");
  #system("mv tmp $spascript");

}

sub update_for_gls{
  my $topModule = "${testbench}/dut_${topMod}.sv";
  my $previousLine = '';
  my $instance = 0;
  my $initial_sdf = 0;
  
  open(INFILE, "<$topModule");
  open(OUTFILE, ">tmp");

  foreach my $line (<INFILE>) {
    
    if($line =~ /${topMod}/ && ($instance == 0)) {
      $instance = 1;
    }

    if($line =~ /configure_virtual_interfaces\(\);/ && $initial_sdf eq 0) {$initial_sdf = 1;}
    elsif($line =~ /configure_virtual_interfaces\(\);/ && $initial_sdf eq 1) {
      $initial_sdf = 2;
      print OUTFILE "\n\t `ifdef SDF\n\t\t\t\$sdf_annotate(\"${topMod}_syn.sdf\",i_${topMod},,\"sdf.log\", \"MAXIMUM\");\n\t `endif\n";
    } 

    if(($line =~ /end of instance/) && ($instance == 1)){
      print OUTFILE "`ifdef GATE\n";
      print OUTFILE "\t\t\t.test_se(1'b0),\n";
      print OUTFILE "`endif\n";
      print OUTFILE "$previousLine";
      $instance = 2;
    }
    elsif($previousLine ne ""){
      print OUTFILE "$previousLine";
    }

    $previousLine = $line;
  }
    
  if($previousLine ne ""){
    print OUTFILE "$previousLine";
  }

  close(INFILE);
  close(OUTFILE);
  system("rm -Rf $topModule");
  system("mv tmp $topModule");

}
